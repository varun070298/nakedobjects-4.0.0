<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title>Naked Objects</title>

    <subtitle>Guide and Reference</subtitle>

    <releaseinfo>4.0</releaseinfo>

    <authorgroup>
      <author>
        <firstname>Robert</firstname>

        <surname>Matthews</surname>
      </author>

      <author>
        <firstname>Richard</firstname>

        <surname>Pawson</surname>
      </author>

      <author>
        <firstname>Stef</firstname>

        <surname>Cascarini</surname>
      </author>

      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para>This manual describes how to develop applications to run with the
    Naked Objects framework, from simple prototypes to enterprise
    systems.</para>

    <para>You can download Naked Objects via <ulink
    url="www.nakedobjects.org">www.nakedobjects.org</ulink>, or direct from
    <ulink
    url="http://sourceforge.net/projects/nakedobjects/">SourceForge</ulink>,
    under an open source licence.</para>

    <para>This edition of the manual is intended for use with version 4 of the
    Naked Objects framework, which works with Java version 1.5 or
    higher.</para>

    <note>
      <para>Please note that the Hibernate plugin is not available in version
      4.0, although it should be available in a subsequent release. Therefore,
      the sections of this manual that talk about Hibernate are not relevant
      at this time.</para>
    </note>
  </preface>

  <part>
    <title>Introduction</title>

    <partintro>
      <para>This part of the documentation aims at getting you started with
      Naked Objects in a short space of time. It cover basic installation,
      building applications, running them and then an overview of how they
      actually work. The next part of the manual then goes into each of these
      areas in more detail.</para>
    </partintro>

    <chapter>
      <title>A quick tutorial</title>

      <para></para>

      <section>
        <title>Installing Naked Objects</title>

        <para>Before we launch into using and developing Naked Objects you
        need to have the Naked Objects binary distribuion installed. This is
        covered in this section if you have not already installed it. There
        are other ways of building and running Naked Objects, but these are
        covered in the next part of this manual.</para>

        <section>
          <title>Prerequisites</title>

          <para>To build and run Naked Objects applications for this tutorial
          you need Java version 1.5<footnote>
              <para>Download from <ulink type=""
              url="http://java.sun.com/">http://java.sun.com/</ulink></para>
            </footnote> or above and Ant 1.7<footnote>
              <para>Download from <ulink
              url="http://ant.apache.org/">http://ant.apache.org/</ulink></para>
            </footnote> installed on your machine.</para>
        </section>

        <section>
          <title>Downloading the framework</title>

          <para>The latest version of the Naked Objects framework can be
          downloaded from the downloads page of the Naked Objects Sourceforge
          project<footnote>
              <para>See <ulink
              url="http://sourceforge.net/projects/nakedobjects/">http://sourceforge.net/projects/nakedobjects/</ulink></para>
            </footnote> as shown below. For this tutorial you should download
          the binary release (suffixed with '-for-ant' ) for immediate use.
          (There are three other versions available, suffixed '-for-maven'
          '-source', and '-libs-only-with-dependencies'. You can ignore these
          for now.</para>

          <remark>TODO: replace screenshot below with that for NOF
          4.0.</remark>

          <screenshot>
            <screeninfo></screeninfo>

            <mediaobject>
              <imageobject>
                <imagedata contentwidth="40%" fileref="images/downloads.png" />
              </imageobject>
            </mediaobject>
          </screenshot>
        </section>

        <section>
          <title>Installation</title>

          <para>Extract the downloaded file's content into a suitable
          directory (a root directory is created upon extraction so there is
          no need to create a directory in which to install everything). As an
          example here is the compressed tar file being extracted</para>

          <programlisting>$ tar xzf nakedobjects-4.0-for-ant.tar.gz</programlisting>

          <para>Once expanded you should have the following directories and
          files:</para>

          <programlisting>/nakedobjects-4.0
    /demos
    /docs
    /examples
    /lib
    LICENSE.TXT
    /resources
</programlisting>

          <para>Change into the Naked Objects directory before continuing the
          tutorial<programlisting>$ cd nakedobjects-4.0</programlisting></para>
        </section>
      </section>

      <section>
        <title>Running the Expenses demo application</title>

        <para>The Naked Objects distribution comes with a demonstration
        application for expenses processing i.e. for creating, submitting and
        approving expense claims. The application has only limited
        functionality - a real expenses processing application would require
        many more features - but what it has is realistic in terms of
        implementation.</para>

        <para>There are two ways in which you can run the demonstration: as a
        standalone executable, or building it and running it from within a
        development environment. This chapter covers the former approach and
        looks at how a Naked Objects application is used, while the next
        chapter looks at building and modifying the example allowing you to
        browse and modify the source code.</para>

        <para>The files for running the demo can be found in the
        <filename>demo/expenses</filename> directory, while the source code
        and build files are in the <filename>examples/expenses</filename>
        directory.</para>

        <section>
          <title>Running with the Drag and Drop user interface</title>

          <para>The executable version of the Expenses demo application exists
          within the <filename class="directory"
          moreinfo="none">demos</filename> directory of the Naked Objects
          distribution.</para>

          <screenshot>
            <screeninfo></screeninfo>

            <mediaobject>
              <imageobject>
                <imagedata contentwidth="40%"
                           fileref="images/explorer-files.png" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <para>Run the batch file <filename class="directory"
          moreinfo="none">ExpensesDND.bat</filename> file either by
          double-clicking on the icon (in Windows) or using the following
          commands on the command line. In Windows the commands are</para>

          <programlisting>&gt; cd demos\expenses 
&gt; ExpensesDND.bat</programlisting>

          <para>while on the Mac or when using Unix/Linux they are:</para>

          <programlisting>$ cd demos/expenses 
$ ./ExpensesDND.sh</programlisting>

          <para>After seeing the Naked Objects splash screen, you'll be
          presented with a Login screen:</para>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="40%" fileref="images/log-on-dnd.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <para>Log in as 'sven' and a password of 'pass'. The application
          will then open like this:</para>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="40%" fileref="images/home-dnd.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <para>When an application is started an application window is opened
          and the user's services are displayed on the left hand side. These
          icons typically give the user access to the domain objects held and
          used by the system, and provide a way for to create new instances.
          Any other object that subsequently appears on the screen represents
          one of those domain objects.</para>

          <remark>TODO replace with up-to-date shot using current
          example</remark>

          <screenshot>
            <screeninfo></screeninfo>

            <mediaobject>
              <imageobject>
                <imagedata contentwidth="40%" fileref="images/dnd-example.png" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <para>The service and objects can be manipulated as follows:</para>

          <itemizedlist>
            <listitem>
              <para>Object actions can be invoked by
              <emphasis>right-clicking</emphasis> on an icon and selecting one
              of the options from the menu.</para>
            </listitem>

            <listitem>
              <para>Service actions can be invoked by
              <emphasis>right-clicking</emphasis> on a service icon.</para>
            </listitem>

            <listitem>
              <para>To inspect an object (when only an icon is shown)
              <emphasis>double-click</emphasis> it - this normally opens up
              the object in a new window.</para>
            </listitem>

            <listitem>
              <para>Objects can be dragged by
              <emphasis>click-dragging</emphasis> on an icon and dropped by
              releasing the mouse button.</para>
            </listitem>

            <listitem>
              <para>Dragged objects can be dropped on to an empty object field
              (identified by the grey hole; the label to the right of the hole
              specifies what type of object can be dropped). If the object can
              be dropped into that field then it will flash green. If the
              object cannot be dropped - either because it is the wrong type
              or that specific object is disallowed for some other reason -
              then the field will flash red. Dropping an object into a field
              sets up that field, effectively associating the two
              objects.</para>
            </listitem>

            <listitem>
              <para>Dragged objects can be dropped onto other object icons. If
              the object that you attempting to drop onto accepts that type of
              object then it will flash green. If that object does not accept
              that kind of object, or disallows that specific object, then it
              will flash red. Dropping one object onto another invokes a
              specific object action, for example: add this product to that
              order.</para>
            </listitem>

            <listitem>
              <para>To quit the application, or access other application
              related options right-click on the desktop to bring up the
              system menu.</para>
            </listitem>

            <listitem>
              <para><emphasis>Right-clicking</emphasis> on the border of a
              view (window or icon) will bring up the view menu, allowing the
              objects to be show in other ways.</para>
            </listitem>
          </itemizedlist>

          <remark>TODO add examples interactions for the demo</remark>
        </section>

        <section>
          <title>Running with the HTML user interface</title>

          <para>To run the expenses demo with the HTML user interface, run the
          batch file <filename class="directory"
          moreinfo="none">ExpensesHTML.bat</filename> either by
          double-clicking on the icon (in Windows) or using the following
          commands on the command line. In Windows the commands are:</para>

          <programlisting>&gt; cd demos\expenses 
&gt; ExpensesHTML.bat</programlisting>

          <para>while on the Mac or when using Unix/Linux they are:</para>

          <programlisting>$ cd demos/expenses 
$ ./ExpensesHTML.sh</programlisting>

          <para>Allowing a few seconds for the application to start up, you
          then need to launch a browser and point it to <filename
          class="directory"
          moreinfo="none">http://localhost:8080/logon.app</filename> and
          you'll be presented with a Login screen.</para>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata contentwidth="40%" fileref="images/html-login.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <para>Log in as 'sven' and a password of 'pass'. This will direct
          you to the start page of the application, a welcome page is
          displayed and links to the application services are shown across the
          top. In the same ways as for DND these links give the user access to
          the objects held and used by the system and provide a way to create
          new objects. Any other object that subsequently appears on the
          screen represents one of those objects.</para>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata contentdepth="40%" fileref="images/html-start.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <para>For example if the claims link is clicked on within the
          expenses demo the claims service page is shown with the resource
          actions available in a menu on the left hand side of the
          screen.</para>

          <screenshot>
            <screeninfo></screeninfo>

            <mediaobject>
              <imageobject>
                <imagedata contentwidth="40%"
                           fileref="images/html-exampl-claims.png" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <itemizedlist>
            <listitem>
              <para>Object actions can be invoked by clicking on one of the
              options from the left hand menu.</para>
            </listitem>

            <listitem>
              <para>Resource actions can be invoked by clicking on a service
              icon link in the resource bar and then clicking on a menu
              item.</para>
            </listitem>

            <listitem>
              <para>As objects are created or opened they are shown as links
              in an object history beneath the resource bar.</para>
            </listitem>

            <listitem>
              <para>Similarly the current context, i.e. the current nesting of
              actions, is shown beneath the object history.</para>
            </listitem>
          </itemizedlist>

          <remark>TODO add examples interactions for the demo</remark>
        </section>
      </section>

      <section>
        <title>Developing a Naked Objects application</title>

        <para>Now that you have used an application created for Naked Objects
        we will now look at how to develop one of your own. This chapter
        explains how to build, run and modify a prototype.</para>

        <section>
          <title>Compiling and running an example</title>

          <para>The examples directory contains a couple of examples. Here we
          will use the expenses one. After going to the directory we can use
          Ant to compile and run the code.</para>

          <screen>$ cd example/expenses
$ ant
Buildfile: build.xml

compile:
    [mkdir] Created dir: /home/rcm/tmp/install/nakedobjects-4.0/examples/expenses/build
    [mkdir] Created dir: /home/rcm/tmp/install/nakedobjects-4.0/examples/expenses/build/classes
    [javac] Compiling 59 source files to /home/rcm/tmp/install/nakedobjects-4.0/examples/expenses/build/classes
    [javac] Note: Some input files use or override a deprecated API.
    [javac] Note: Recompile with -Xlint:deprecation for details.
    [javac] Note: Some input files use unchecked or unsafe operations.
    [javac] Note: Recompile with -Xlint:unchecked for details.

dnd:</screen>

          <para>(Remember under Windows paths need to use backslashes instead
          of slashes.)</para>
        </section>
      </section>
    </chapter>

    <chapter>
      <title>Understanding how a Naked Objects application works</title>

      <para>Naked Objects creates the user interface for an application
      directly from the definitions of the domain model. In this section we
      will look at that relationship in more detail, with reference to the
      Expenses Processing example application supplied as part of the
      download. As we showed in the previous section, any domain model written
      for Naked Objects may be run with any of the viewers - there is no
      specific coding required, and the domain model has no knowledge of which
      viewer is being used. However, each viewer will have different gestures
      or mechanisms for providing the same functionality. To illustrate this,
      we will show the same objects being accessed through both the DND and
      the HTML viewers, side by side.</para>

      <para>The application code for the Expenses Processing example, like any
      Naked Objects application, consists of two things: domain objects and
      services. The domain objects form the lion's share of that code, so
      we'll look at how those work first.</para>

      <para>The code for examples we will be looking at can be found in the
      directory <filename>examples/expenses/expenses-dom/src</filename> in the
      downloaded files.</para>

      <sect1>
        <title>Domain objects</title>

        <para>The domain objects are the entities - the nouns - that represent
        the application domain: employee, claim, expense item, project code,
        currency, and so forth. In the course of using the application, a user
        will view and manipulate many instances of these domain objects. To
        understand how Naked Objects handles domain objects, we'll start by
        looking at an Employee object:</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="40%"
                         fileref="images/employee-views.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>Every object presented in the user interface will have a
        corresponding Java class in the domain model - in this case it is
        <classname>org.nakedobjects.example.expenses.employee.Employee</classname>.
        Below we can see the code for the <classname>Employee</classname>
        object, as presented in Eclipse, with the object's list of methods
        presented on the left hand side.</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="40%" fileref="images/employee-code.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>The first thing to note is that the type of the object as shown
        in the user views is derived directly from the class name in Java. The
        framework inserts spaces before capital letters, so that the class
        <classname>TemporaryEmployee</classname> would be presented to the
        user as 'Temporary Employee'. However we will see later that the name
        may be over-ridden where necessary, for example if we want the name to
        include punctuation or other characters not allowed in Java class
        names. (Note that there is a separate mechanism for dealing with
        internationalisation).</para>

        <para>Secondly, we can see that <classname>Employee</classname>
        extends <classname>AbstractDomainObject</classname> - a class provided
        within the Naked Objects application library. This is not a
        requirement: your domain objects may be Plain Old Java Objects (POJOs)
        - they do not need to extend any class in the framework. However,
        extending from <literal moreinfo="none">AbstractDomainObject</literal>
        will save us having to write a few lines of code in each case, as
        we'll see later.</para>

        <para>Note also that in the body of the object we use 'code folding'
        (the plug-in used here is <ulink
        url="http://www.realjenius.com/platform_support">Coffee Bytes</ulink>)
        to break the object's code into regions, each typically containing one
        or more related methods that together fulfill a high-level
        responsibility of the object. This is just a coding convention, not a
        requirement.</para>
      </sect1>

      <sect1>
        <title>Properties</title>

        <para>In both of the user views of an Employee we can see a field
        called 'Name'. Within the <classname>Employee</classname> class there
        is a <literal moreinfo="none">Name</literal> region of code, expanded
        here:</para>

        <programlisting condition="" format="linespecific">// {{ Name
    private String name;

    @MemberOrder(sequence="1")
    @Disabled
    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }
// }}</programlisting>

        <para>The <literal moreinfo="none">Name</literal> region contains a
        simple property, of type <literal moreinfo="none">String</literal>,
        defined by a <literal moreinfo="none">getName</literal> and a <literal
        moreinfo="none">setName</literal> method. This is sufficient
        information to allow the viewers to display a field containing a
        textual value. Note that if the property is to be persisted, then it
        will need both a <literal moreinfo="none">get</literal> and a <literal
        moreinfo="none">set</literal> method - per the standard JavaBeans
        convention. If you wish to display a field that is derived
        automatically from other information in the object, and do not require
        this to be persisted, then a <literal moreinfo="none">get</literal>
        alone will suffice.</para>

        <para>As with the name of the object, the field name is derived
        automatically from the name of the property - though we'll see later
        that this may be over-ridden if needed.</para>

        <para>The <literal moreinfo="none">getName</literal> has been marked
        up with two Java annotations, both defined in the Naked Objects
        application library. Annotations allow the programmer to enrich the
        information available to the framework. On properties, any Naked
        Objects annotations are always associated with the <literal
        moreinfo="none">get</literal> method. However, annotations are not
        mandatory - you can write a simple Naked Objects application without
        using any annotations at all.</para>

        <para>By default, any property with both a <literal
        moreinfo="none">get</literal> and <literal
        moreinfo="none">set</literal> method will be editable by the user.
        <literal moreinfo="none">@Disabled</literal> tells the framework that
        this particular property may never be altered by the user (though it
        may be altered programmatically). Later we'll see how to make a
        property modifiable on certain conditions.</para>

        <para><literal moreinfo="none">@MemberOrder(sequence="1")
        </literal>tells the framework that this property should be the first
        field displayed in any view of the Employee - irrespective of where it
        is defined within the code. This ordering information has been
        observed by both the viewers.</para>

        <para>The next region of the code contains another <literal
        moreinfo="none">String</literal> property, called <literal
        moreinfo="none">UserName</literal>:</para>

        <programlisting format="linespecific">// {{ UserName field
    private String userName;

    @Hidden
    public String getUserName() {
        return userName;
    }
    public void setUserName(final String variable) {
        this.userName = variable;
    }
// }}</programlisting>

        <para>Note that <literal moreinfo="none">getUserName</literal> has
        been marked up with <literal moreinfo="none">@Hidden</literal>. This
        tells the framework that this property should never be shown in user
        views of the object (check this against the two user views above).
        Later on we'll see how it is possible to hide a property in certain
        circumstances.</para>

        <para>Next we'll look at the <literal
        moreinfo="none">EmailAddress</literal> region:</para>

        <programlisting format="linespecific">// {{ EmailAddress
    private String emailAddress;
    
    @MemberOrder(sequence = "2")
    @Optional
    @RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")
    public String getEmailAddress() {
        return this.emailAddress;
    }
    public void setEmailAddress(final String emailAddress) {
        this.emailAddress = emailAddress;
    }
    public void modifyEmailAddress(final String emailAddress) {
        getRecordActionService().recordFieldChange(this, "Email Address", getEmailAddress(), emailAddress);
        setEmailAddress(emailAddress);
    }
    public void clearEmailAddress() {
        getRecordActionService().recordFieldChange(this, "Email Address", getEmailAddress(), "EMPTY");
        setEmailAddress(null);
    }
    public boolean hideEmailAddress() {
        return !employeeIsCurrentUser();
    }
    private boolean employeeIsCurrentUser() {
        return getUserFinder().currentUserAsObject() == this;
    }
// }}</programlisting>

        <para>As well as <literal moreinfo="none">@MemberOrder</literal>, this
        property is marked up with <literal
        moreinfo="none">@Optional</literal> and <literal
        moreinfo="none">@RegEx</literal> annotations. By default, all
        properties are taken to be mandatory - if the user creates or edits an
        object then they will be required to specify the contents of each
        field. <literal moreinfo="none">@Optional</literal> overrides this
        default behaviour - indicating here that the object may be saved
        without an email address.</para>

        <para><literal moreinfo="none">@RegEx</literal> is applicable only to
        <literal moreinfo="none">String</literal> properties. In this case the
        annotation specifies a Regular Expression that will be used to
        validate any value that the user types into the field. In a
        conventional architecture, this functionality would typically be found
        in the user interface code. The Naked Objects argument is that this
        functionality should apply to any user interface that might want to
        change the property, so its proper place is in the object. <literal
        moreinfo="none">@RegEx</literal> may also be used to reformat a String
        that has been entered by the user.</para>

        <para>The two screens below show how two different viewers make use of
        the functionality in different ways. In both cases the user has typed
        in a value that does not match the RegEx specification (they have
        typed in an email address that contains a space), so the new value has
        not been accepted or saved.</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="40%"
                         fileref="images/employee-email-invalid.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>In addition to <literal
        moreinfo="none">getEmailAddress</literal> and <literal
        moreinfo="none">setEmailAddress</literal>, there are <literal
        moreinfo="none">modifyEmailAddress</literal>, <literal
        moreinfo="none">clearEmailAddress</literal> and <literal
        moreinfo="none">hideEmailAddress</literal> methods. Naked Objects
        recognises the <literal moreinfo="none">modify</literal>, <literal
        moreinfo="none">clear</literal> and <literal
        moreinfo="none">hide</literal> prefixes (and a few others that we
        shall see later) as specifying additional functionality relating to
        the <literal moreinfo="none">EmailAddress</literal> property.</para>

        <para>If a property has a corresponding <literal
        moreinfo="none">modify&lt;propertyName&gt;</literal> method, then
        whenever the user modifies the field, this will be called rather than
        the <literal moreinfo="none">set</literal>. In this case the <literal
        moreinfo="none">modify</literal> method uses the <literal
        moreinfo="none">RecordActionService</literal> to record the details of
        the change, and then calls <literal
        moreinfo="none">setEmailAddress</literal> to change the value. The
        reason for adopting this pattern, rather than including the
        functionality in the <literal moreinfo="none">set</literal> itself, is
        that the <literal moreinfo="none">set</literal> will be called by the
        object store each time the object is retrieved. So we use a <literal
        moreinfo="none">modify</literal> method where we want to do something
        (such as add to a total) only when the user changes a field.</para>

        <para><literal moreinfo="none">clearEmailAddress</literal> is called,
        in a similar manner, if the user clears the contents of the field.
        Again, it is optional - added where we want to perform some logic only
        when the user clears the property. On the <literal
        moreinfo="none">UserName</literal> field we saw that <literal
        moreinfo="none">@Hidden</literal> hides a property from the user
        permanently. We may, however, want to hide fields under certain
        circumstances. The visibility of all classes, properties and methods
        may be controlled via conventional authorization techniques, based on
        the user's role(s). In rarer cases, we want to control visibility at
        an instance level. In this case, for privacy reasons we do not want
        the email address to be visible, except to that person. This is what
        the <literal moreinfo="none">hideEmailAddress()</literal>method is
        doing. If the method returns true, the field will be hidden from the
        user.</para>

        <para>Next we will look at the <literal
        moreinfo="none">NormalApprover</literal> region:</para>

        <programlisting format="linespecific">// {{ NormalApprover
    private Employee normalApprover;
    
    @MemberOrder(sequence="4")
    public Employee getNormalApprover() {
        return this.normalApprover;
    }
    public void setNormalApprover(final Employee normalAuthoriser) {
        this.normalApprover = normalAuthoriser;
    }
    public void modifyNormalApprover(final Employee normalAuthoriser) {
        getRecordActionService().recordFieldChange(this, "Normal Approver", getNormalApprover(), normalApprover);
        setNormalApprover(normalAuthoriser);
    }
    public void clearNormalApprover() {
        getRecordActionService().recordFieldChange(this, "Normal Approver", getNormalApprover(), "EMPTY");
        setNormalApprover(null);
    }
    public String validateNormalApprover(Employee newApprover) {
        return newApprover == this ? CANT_BE_APPROVER_FOR_OWN_CLAIMS: null;
    }
    public String disableNormalApprover() {
        return employeeIsCurrentUser() ? null: NOT_MODIFIABLE;
    }
    
    public static final String NOT_MODIFIABLE = "Not modifiable by current user";
    public static final String CANT_BE_APPROVER_FOR_OWN_CLAIMS = "Can't be the approver for your own claims";
// }}</programlisting>

        <para>The <literal moreinfo="none">NormalApprover</literal> property
        takes an object of type <literal moreinfo="none">Employee</literal>.
        Assuming that this field is not disabled, the user may specify an
        Employee object for this field. Naked Objects will prevent the user
        from trying to associate the wrong type of object with this field.
        This is illustrated in the two screens below:</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="40%"
                         fileref="images/employee-approver-views.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>In the left-hand screen (DND) we can see the user dropping an
        Employee object into the empty field, and the field is flashing green
        to indicate that this will succeed. If the user attempted to drop
        another type of object into the empty field, then the field would
        flash red, and the drop would not update the field. A successful drop
        will call the <literal moreinfo="none">set</literal> method, or, if a
        <literal moreinfo="none">modify&lt;propertyName&gt;</literal> method
        is provided (as it is here), it will call that instead. Note that on
        the DND viewer, if a field already contains an object, then this may
        be cleared by right-clicking on that object and selecting 'Clear
        Association'. This will set the property to <literal
        moreinfo="none">null</literal>. If there is a <literal
        moreinfo="none">clear&lt;propertyName&gt;</literal> field (as there is
        in this example) then that will be called rather than the <literal
        moreinfo="none">set</literal> method. Alternatively a new reference
        can be dropped on to the field's label, which combines both the
        clearing and the subsequent setting of the field.</para>

        <para>In the HTML viewer (right-hand screen) drag and drop is not
        possible. In a reference field such as this one, the user will be
        given a drop-down list of objects of the appropriate type (i.e.
        Employees here) that the user has recently viewed. If the required
        Employee object is not in that list then the user may go and find that
        object (e.g. from the Employees tab) and then return to the context -
        this time the newly viewed Employee will have been added to the list
        automatically. (Note: This is a generic capability provided by the
        HTML viewer. In other contexts, the programmer may want to specify an
        explicit list of objects to appear in a drop-down list. This would be
        achieved by means of a <literal
        moreinfo="none">choices&lt;propertyName&gt;</literal> method).</para>

        <para>The <literal moreinfo="none">validateNormalApprover</literal>
        method enforces any rules concerning the specific instances of
        <literal moreinfo="none">Employee</literal> that may be associated
        with this field. In this particular example, it prevents the user from
        specifying an Employee as their own approver. Note that this method
        returns a <literal moreinfo="none">String</literal>. If the specific
        Employee instance being passed into the method is acceptable, the
        method should return <literal moreinfo="none">null</literal>; if
        unacceptable then the method should return a <literal
        moreinfo="none">String</literal> message that will be made available
        to the user to advise them why the action will not succeed. (On the
        DND this appears at the bottom of the screen.)</para>

        <para>The <literal moreinfo="none">disableNormalApprover</literal>
        method prevents the user from modifying the field in certain
        circumstances. In this example the method enforces the rule that only
        the Employee themselves may change this field. Like the <literal
        moreinfo="none">validate</literal> method, it returns a <literal
        moreinfo="none">null</literal> if the user may modify the field
        (subject to the validate rules), or returns a <literal
        moreinfo="none">String</literal> message if they may not. (Note that
        this method, along with hide (seen earlier) allow for 'instance-based
        authorization'. Most applications can manage with 'class-based
        authorization' - in which the classes, properties and actions made
        available to a user are based on their roles. Class-based
        authorization in Naked Objects is administered externally to the
        application and does not require any coding within the domain
        objects.)</para>
      </sect1>

      <sect1>
        <title>Title</title>

        <para>In the next screen we will look at the <literal
        moreinfo="none">title</literal> region of the Employee object.</para>

        <programlisting format="linespecific">// {{ Title
    public String title() {
        return getName();
    }
// }}</programlisting>

        <para>The <literal moreinfo="none">title</literal> method specifies
        the title for the object - which, on both the DND and HTML viewers
        appears next to the icon. The title is there to help the user identify
        objects. Naked Objects also provides an easy mechanism to retrieve
        objects from the object store by their title. Other methods of
        finding/searching may require repository methods to be written. If no
        <literal moreinfo="none">title</literal> method is specified, Naked
        Objects will use the object's <literal
        moreinfo="none">toString</literal> method as a title. Titles are
        usually based on one or more of the persisted properties - in this
        case on the Name. When constructing a title from multiple elements,
        the Naked Objects application library provides a helper object:
        <classname>TitleBuffer</classname>.</para>
      </sect1>

      <sect1>
        <title>Actions</title>

        <para>The screen below shows the action menu for the Taxi object, as
        rendered by the two different user interfaces:</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="40%" fileref="images/taxi-menu.png"
                         format="PNG" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>By default, any <literal moreinfo="none">public</literal>
        instance methods on an object, included inherited public methods, will
        be rendered as a user-action. The exceptions to this rule are:</para>

        <itemizedlist>
          <listitem>
            <para>Any methods that are recognised by Naked Objects as having a
            specific intent. We've seen a number of these already, including
            <literal moreinfo="none">get</literal> and <literal
            moreinfo="none">set</literal> methods, <literal
            moreinfo="none">title</literal>, and the methods prefixed by
            <literal moreinfo="none">modify</literal>, <literal
            moreinfo="none">clear</literal>, <literal
            moreinfo="none">validate</literal>, <literal
            moreinfo="none">disable</literal> and so on. There is a full list
            of recognised methods included in the section <xref
            linkend="recognised-methods" />.</para>
          </listitem>

          <listitem>
            <para>Any methods that the programmer has specified should be
            hidden from the user, either statically with <literal
            moreinfo="none">@Hidden</literal>, or dynamically with a <literal
            moreinfo="none">hide&lt;methodName&gt;</literal> method.</para>
          </listitem>
        </itemizedlist>

        <para><literal moreinfo="none">private</literal>, <literal
        moreinfo="none">protected</literal>, and <literal
        moreinfo="none">static</literal> methods are ignored by Naked
        Objects.</para>

        <para>For example, the action 'Copy From' on the Taxi object, is
        derived from this method on the
        <classname>AbstractExpenseItem</classname> class (from which
        <classname>Taxi</classname> inherits):</para>

        <programlisting format="linespecific">    @MemberOrder(sequence="5")
    public void copyFrom(final ExpenseItem otherItem) {
        if (belongsToSameClaim(otherItem)) {
            if (dateIncurred == null) {
                modifyDateIncurred(otherItem.getDateIncurred());
            }
        } else if (getClass().isInstance(otherItem)) {
            copyAllSameClassFields(otherItem);
        }
    }</programlisting>

        <para>Again, we can see that the method has been marked up with
        <literal moreinfo="none">@MemberOrder</literal>, which will govern the
        relative location of this action on the action menu.</para>

        <para>Because the <literal moreinfo="none">copyFrom</literal> method
        takes a parameter, when the user invokes the corresponding menu action
        they will be presented with a dialog, wherein each of the parameters
        may be specified. This is shown below on the two user
        interfaces:</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="40%"
                         fileref="images/taxi-copy-dialog.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>Editing a dialog is similar to editing an object: though there
        are differences in the way they are rendered (for example a dialog has
        an 'OK' button in both the DND and HTML user interfaces). Parameters
        that take value types (such as <classname>String</classname> or
        <classname>Date</classname>) are rendered as fields that the user can
        type into. Where a parameter is a domain object class or interface, as
        in this case with <classname>ExpenseItem</classname>, then the user
        must specify an object of that type. In the DND user interface, the
        user may drag and drop an object into the parameter field. In the HTML
        user interface, the user is automatically presented with a drop-down
        list of objects of that type that they have recently viewed. If the
        desired object doesn't appear, they may go and find the object (by
        navigating from another object, or using a find method on one of the
        start points) and then return to the dialog, where the
        recently-located object should now appear on the list.</para>

        <para>Adjacent to the <literal moreinfo="none">copyFrom</literal>
        method on <classname>AbstractExpenseItem</classname> we can also find
        the following two methods:</para>

        <programlisting format="linespecific">    public String disableCopyFrom() {
        return disabledIfLocked();
    }

    public String validateCopyFrom(final ExpenseItem otherItem) {
        if (belongsToSameClaim(otherItem) || (getClass().equals(otherItem.getClass()))) {
            return null;
        }
        return COPY_WARN;
    }
    private final static String COPY_WARN = "Cannot copy";</programlisting>

        <para><literal moreinfo="none">disableCopyFrom</literal> and <literal
        moreinfo="none">validateCopyFrom</literal> are other examples of
        recognised methods (see <xref linkend="recognised-methods" />). They
        work in a similar manner to the <literal
        moreinfo="none">disable&lt;propertyName&gt;</literal> and <literal
        moreinfo="none">validate&lt;propertyName&gt;</literal> methods that we
        have previously seen - in this case disabling the action under certain
        conditions, and validating the parameters of the action. For both the
        user-interfaces shown, disabling the action will result in it being
        greyed-out on the menu. If the entered set of parameters does not pass
        the validity test, this will be brought to the user's attention when
        they attempt to execute the action (e.g. by hitting the OK button),
        along with an explanatory message.</para>

        <para>By default, the user will be required to specify each of the
        parameters within the dialog. The programmer may, however, use the
        <literal moreinfo="none">@Optional </literal>annotation in-line (i.e.
        immediately before any parameter in the method signature) to specify
        that that parameter may be left empty.</para>
      </sect1>

      <sect1>
        <title>Defining Services</title>

        <para>As stated previously all the application code consists either of
        domain objects or services, with the former typically representing the
        lions share of the code. Now we'll look at the services.</para>

        <para>Services perform two roles in a Naked Objects application.
        First, they provide a place to put functionality that cannot be placed
        on an instance of a domain object, of which the two most obvious
        examples are:</para>

        <itemizedlist>
          <listitem>
            <para>Finding one or more domain objects where you don't have an
            associated object to navigate from e.g. finding a Customer object
            by their name or customer number.</para>
          </listitem>

          <listitem>
            <para>Creating a new instance of a domain object class, where you
            don't have an existing object to create it from. Thus, although
            you might decide that it makes sense to create a new Order object
            by means of an action on Customer, you will probably want to be
            able to create a new Customer object without necessarily having
            any Order.</para>
          </listitem>
        </itemizedlist>

        <para>To fulfill these requirements we could create two separate
        services, called, say, CustomerFinder and CustomerFactory. Or we could
        create a single service called, say, Customers, which has methods to
        cover both requirements. There's no hard-and-fast rule about how
        services should be partitioned.</para>

        <para>The second role that services perform within a Naked Objects
        application is to bridge domains. The following are examples of what
        we mean by bridging domains:</para>

        <itemizedlist>
          <listitem>
            <para>Linking to functionality that already exists, or has to
            exist, outside of the Naked Objects application, such as
            pre-existing services, or functionality within legacy
            systems.</para>
          </listitem>

          <listitem>
            <para>Bridging between technical domains, such as between the
            object domain and the relational database domain, or the email
            domain.</para>
          </listitem>

          <listitem>
            <para>(Less commonly) Bridging between isolated modelling domains.
            The Naked Objects philosophy is to aim, where possible, for a
            single coherent enterprise object model running within the same
            application space. Where this is not possible (e.g. for technical
            or for political reasons), then services may be used to
            communicate between the domains without requiring common object
            definitions and/or identities.</para>
          </listitem>
        </itemizedlist>

        <para>In this section we'll look at how services are defined, and in
        the next section at how they are used.</para>

        <para>Services are implemented as Java classes, as are domain objects,
        but they are handled differently by the framework.</para>

        <para>It is good practice to define services as Java interfaces. That
        way it is possible for the implementation of the service to change
        over time, without affecting any of the objects that use the service.
        During development it is often useful to develop a simple 'mock'
        implementation of a service that can be used either for prototyping or
        testing purposes; this can then be replaced with a proper
        implementation as development progresses towards deployment. For
        example, within the Expenses Processing application, the following
        Java interface defines a service for sending an email:</para>

        <programlisting format="linespecific">    package org.nakedobjects.example.expenses.services;

    public interface EmailSender {

        void sendTextEmail(final String toEmailAddress, final String text);
    }</programlisting>

        <para>This service definition has just one method, but it could easily
        have more, such as methods that take a <literal
        moreinfo="none">List</literal> of recipient addresses, or that can
        accommodate file attachments. <literal
        moreinfo="none">JavaMailSender</literal> is an implementation of that
        service:</para>

        <programlisting format="linespecific">public class JavaMailSender extends AbstractService implements EmailSender {

    private static final String SMTP_HOST_NAME = "localhost";
    private static final String SMTP_AUTH_USER = "expenses@donotreply.org";
    private static final String SMTP_AUTH_PWD = "";
    private static final boolean authenticate = false;

    private class SMTPAuthenticator extends javax.mail.Authenticator {
        public PasswordAuthentication getPasswordAuthentication() {
            final String username = SMTP_AUTH_USER;
            final String password = SMTP_AUTH_PWD;
            return new PasswordAuthentication(username, password);
        }
    }

    public void sendTextEmail(final String toEmailAddress, final String text) {
        try {
            final Properties properties = new Properties();
            properties.put("mail.smtp.host", SMTP_HOST_NAME);
            properties.put("mail.smtp.auth", authenticate ? "true" : "false");
            final Authenticator authenticator = authenticate ? new SMTPAuthenticator() : null;
            final Session session = Session.getDefaultInstance(properties, authenticator);
            final Message message = new MimeMessage(session);
            final InternetAddress fromAddress = new InternetAddress(SMTP_AUTH_USER);
            final InternetAddress toAddress = new InternetAddress(toEmailAddress);
            message.setFrom(fromAddress);
            message.setRecipient(Message.RecipientType.TO, toAddress);
            message.setSubject("Expenses notification");
            message.setContent(text, "text/plain");
            Transport.send(message);
        } catch (AddressException e) {
            throw new ApplicationException("Invalid email address", e);
        } catch (MessagingException e) {
            throw new ApplicationException("Problem sending email", e);
        }
    }
}</programlisting>

        <para>We can see that this service performs a technical bridging role:
        it bridges between the object domain and an external SMTP
        server.</para>

        <para>Since there could be multiple implementations of any one service
        within our code base, Naked Objects needs to be informed of which
        services it is to reference when running an application. This is done
        within the properties files. For example, the <filename
        class="directory" moreinfo="none">nakedobjects.properties</filename>
        file, which may be found within the <literal
        moreinfo="none">expenses.app.client\config</literal> directory,
        contains the property specification:</para>

        <programlisting format="linespecific">nakedobjects.services.prefix=org.nakedobjects.example.expenses
nakedobjects.services=services.JavaMailSender</programlisting>

        <para>This specifies that the class JavaMailSender is to be referenced
        as a service within the application. You will find a list of other
        services being referenced there also. Many of those services are
        'repositories', and though there is no technical difference between a
        repository and any other kind of service, repositories play such an
        important role in Naked Objects applications, that they are worth
        exploring in more detail.</para>

        <sect2>
          <title>Repositories</title>

          <para>Naked Objects handles the basic object lifecycle (create,
          read, update, delete) automatically - there is no need to define
          your own methods for saving or updating objects, or for retrieving
          an object that you have a reference to. These mechanisms work the
          same way irrespective of what technology you are using to persist
          the objects - such as via Hibernate, natively to a relational
          database, or via the 'XML Object Store'.</para>

          <para>Naked Objects even provides some simple mechanisms for
          searching for persisted objects - that also operate the same way,
          irrespective of the object store. However, a business application
          will also need more complex search queries that, for reasons of
          efficiency, will need to be written specifically for the type of
          object store you are working with.</para>

          <para>Best practice in application design suggests that such queries
          should be implemented on 'Repository' classes, rather than within
          the domain classes directly. That way if you change the persistent
          object store, you can just create a new implementation of the
          affected Repositories, without having to change any domain classes.
          Naked Objects supports this concept. Within the Expenses application
          you will find the following three repository definitions:</para>

          <programlisting format="linespecific">org.nakedobjects.example.expenses.claims.ClaimRepository
org.nakedobjects.example.expenses.employee.EmployeeRepository;
org.nakedobjects.example.expenses.recordedAction.impl.RecordedActionRepository;</programlisting>

          <para>In each case the repository is defined as a Java interface,
          anticipating the possibility of different implementations. We'll
          look at the <classname>ClaimRepository</classname>
          definition:</para>

          <programlisting format="linespecific">public interface ClaimRepository {
    final static int MAX_CLAIMS = 20;
    final static int MAX_ITEMS = 10;

    List&lt;Claim&gt; findClaims(final Employee employee, final ClaimStatus status, final String description);

    List&lt;Claim&gt; findRecentClaims(final Employee employee);

    boolean descriptionIsUniqueForClaimant(final Employee employee, final String initialDescription);

    List&lt;ExpenseItem&gt; findExpenseItemsLike(final ExpenseItem item);

    List&lt;Claim&gt; findClaimsAwaitingApprovalBy(Employee approver);
    
    ClaimStatus findClaimStatus(String title);

    ExpenseItemStatus findExpenseItemStatus(String title);
}</programlisting>

          <para>This interface defines some seven method signatures for
          retrieving <classname>Claim</classname>s and
          <classname>ExpenseItem</classname>s. Note that there is no hard rule
          about the scope of a single Repository - we could have decided to
          separate this into a <classname>ClaimRepository</classname> and an
          <literal moreinfo="none">ExpenseItemRepository</literal> if that
          offered us some advantage.</para>

          <para>The example application contains two concrete implementations
          of <classname>ClaimRepository</classname>:</para>

          <programlisting format="linespecific">org.nakedobjects.example.expenses.services.inmemory.ClaimRepositoryInMemory
org.nakedobjects.example.expenses.services.hibernate.ClaimRepositoryHibernate</programlisting>

          <para>The first of these is intended for use with a standalone
          prototype - with a relatively small number of object instances, all
          held in memory. So the finder methods can be written 'naively' - to
          enumerate through all the objects in a class and find the match(es).
          The following is its implementation of the
          <methodname>findClaimsAwaitingApprovalBy</methodname> method:</para>

          <programlisting format="linespecific">    public List&lt;Claim&gt; findClaimsAwaitingApprovalBy( final Employee approver ) {
        return allMatches(
            Claim.class, 
            new Filter() {
                public boolean accept(final Object obj) {
                    Claim claim = (Claim) obj;
                    return claim.getStatus().isSubmitted() &amp;&amp; claim.getApprover() == approver;
                }
            });
    }</programlisting>

          <para>This delegates to an <methodname>allMatches</methodname>
          method, inherited from
          <classname>AbstractFactoryAndRepository</classname>, and use a
          <classname>Filter</classname> object (created in-line) to compare to
          each instance of <classname>Claim</classname> held in memory. Such
          methods are very simple to write and debug (because they can invoke
          methods on the objects being searched, such as
          <methodname>isSubmitted</methodname> here), but they would not
          operate efficiently for large numbers of objects.</para>

          <para><classname>ClaimRepositoryHibernate</classname> is written to
          work with the Hibernate Object Store and can work efficiently at
          large scale. Here is its the
          <methodname>findClaimsAwaitingApprovalBy</methodname> method:</para>

          <programlisting format="linespecific">public List&lt;Claim&gt; findClaimsAwaitingApprovalBy( final Employee approver ) {
    final Criteria criteria = hibernateHelper.createCriteria(Claim.class);
    criteria.
        add(Restrictions.eq("approver", approver)).
        createCriteria("status").
        add(Restrictions.eq("titleString", ClaimStatus.SUBMITTED));
    return hibernateHelper.findByCriteria(criteria, Claim.class);
}</programlisting>

          <para>This implementation uses a <classname>Criteria</classname>
          object, a class provided by the <ulink
          url="www.hibernate.org">Hibernate</ulink> framework.</para>

          <para>Both <classname>ClaimRepositoryInMemory</classname> and
          <classname>ClaimRepositoryHibernate</classname> inherit from
          <classname>ClaimRepositoryAbstract</classname>, which inherits from
          <classname>AbstractFactoryAndRepository</classname> and also
          implements the <classname>ClaimRepository</classname> interface.
          This pattern is not a requirement - the implementations do not need
          to inherit from any framework class, they can just implement the
          required Repository interface natively. However the advantage of
          this pattern is that some simple query methods can be written
          generically, as shown in these two examples:</para>

          <programlisting format="linespecific">public List&lt;ExpenseItem&gt; findExpenseItemsOfType(final Employee employee, final ExpenseType type) {
    final List&lt;Claim&gt; claims = findClaims(employee, null, null);
    final List&lt;ExpenseItem&gt; items = new ArrayList&lt;ExpenseItem&gt;();
    for (final Claim claim : claims) {
        ExpenseItem pattern = (ExpenseItem) newTransientInstance((Class) type.correspondingClass());
        pattern.setClaim(claim);
        List list = (List) uniqueMatch((Class) type.correspondingClass(), pattern, EXCLUDING_SUBCLASSES);
        items.addAll(list);
    }
    return items;
}

public ClaimStatus findClaimStatus(String title) {
    return uniqueMatch(ClaimStatus.class, title, EXCLUDING_SUBCLASSES);
}</programlisting>

          <para>These two query methods both delegate to
          <methodname>uniqueMatch</methodname>, inherited from
          <classname>AbstractFactoryAndRepository</classname>, but different,
          overloaded, versions of that method.
          <methodname>findExpenseItemsOfType</methodname> invokes
          <methodname>uniqueMatch</methodname> with a pattern - an instance of
          <classname>ExpenseItem</classname> that has been set up with the
          fields where a match is required.
          <methodname>findClaimStatus</methodname> invokes
          <methodname>uniqueMatch</methodname> with a
          <classname>String</classname> representing the title of the object
          required. The implementation of both of these forms of query is
          delegated to the object store, in a manner that is transparent to
          the application programmer. So, if the nature of the query can be
          represented in the form of a find by title, or a find by pattern,
          then it is advantageous to use these methods on
          <classname>AbstractFactoryAndRepository</classname>. Otherwise you
          can write specialised methods on the respective repository
          implementations.</para>

          <para>As with all services, we need to inform the framework of the
          existence and intent of these implementations, via the properties
          files. Within <filename class="directory"
          moreinfo="none">nakedobjects.properties</filename> you will
          find:</para>

          <programlisting format="linespecific">nakedobjects.services=services.inmemory.ClaimRepositoryInMemory</programlisting>

          <para>and within <filename class="directory"
          moreinfo="none">persistor_hibernate.properties</filename> you will
          find:</para>

          <programlisting format="linespecific">nakedobjects.services = services.hibernate.ClaimRepositoryHibernate</programlisting>

          <para><filename class="directory"
          moreinfo="none">persistor_hibernate.properties</filename> is only
          referenced if the application is run with the Hibernate Object
          Store, in which case the framework will recognise that
          <classname>ClaimRepositoryHibernate</classname> is intended to
          replace <classname>ClaimRepositoryInMemory</classname> as the
          implementation to use.</para>
        </sect2>

        <sect2>
          <title>Factories</title>

          <para>A Factory is just the name we give to a kind of service that
          specialises in the creation of new objects, of one or more kinds. It
          is not necessary to use a Factory in order to create objects within
          Naked Objects: we may invoke the methods
          <methodname>newTransientInstance</methodname> from within a method
          on a domain object or within any service.</para>

          <para>However, if there is a need to create a type of object from
          several different places in the application, and there are common
          steps involved, then it is good practice to delegate this to a
          Factory. Within Naked Objects a Factory is just another service, it
          doesn't have any special status. For example, within the Expenses
          application, new <classname>Claim</classname>s and new
          <classname>ExpenseItem</classname>s are created via the
          <classname>ClaimFactory</classname>. However, new
          <classname>RecordedAction</classname>s are created in the
          <classname>RecordedActionService</classname>. Note that
          <classname>ClaimFactory</classname> is specified as a class rather
          than an interface, because we have no particular reason to
          anticipate different implementations of the factory.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Using services</title>

        <para>Services are used within Naked Objects in three ways:</para>

        <itemizedlist>
          <listitem>
            <para>Injected into domain objects</para>
          </listitem>

          <listitem>
            <para>Directly accessible to the user</para>
          </listitem>

          <listitem>
            <para>To contribute actions to domain objects</para>
          </listitem>
        </itemizedlist>

        <para>We'll look at these three in turn.</para>

        <sect2>
          <title>Injecting Services into domain objects</title>

          <para>Objects may need access to services, such as repositories for
          finding related objects, or for calling functionality from outside
          the domain model. Naked Objects uses the 'dependency injection'
          model. Each object merely needs to provide a <literal
          moreinfo="none">set</literal> method for each type of service that
          it requires. For example, within the Employee object there is a code
          region labelled <literal moreinfo="none">Injected
          Services</literal>:</para>

          <programlisting format="linespecific">// {{ Injected Services
    // {{ Injected: RecordActionService
    private RecordActionService recordActionService;

    protected RecordActionService getRecordActionService() {
        return this.recordActionService;
    }

    public void setRecordActionService(final RecordActionService recordActionService) {
        this.recordActionService = recordActionService;
    }
    // }}

    // {{ Injected: UserFinder
    private UserFinder userFinder;

    protected UserFinder getUserFinder() {
        return this.userFinder;
    }

    public void setUserFinder(final UserFinder userFinder) {
        this.userFinder = userFinder;
    }
    // }}
// }}</programlisting>

          <para>In this case, the Employee object has specified that it
          requires two services to be injected: a <literal
          moreinfo="none">RecordActionService</literal> and a <literal
          moreinfo="none">UserFinder</literal>. Whenever an instance of
          Employee is created, or retrieved from the object store, Naked
          Objects will inject the implementation that it knows about (as
          specified in properties) for each type of service required. Note
          that, unlike the other properties we have looked at, <literal
          moreinfo="none">get</literal> methods may be <literal
          moreinfo="none">protected</literal>, because the property is not
          displayed. (Strictly speaking a <literal
          moreinfo="none">get</literal> is often not needed here - as the
          injected service may be accessed via the variable - but it is
          considered to be good practice.)</para>

          <para>From within the object we can then call any of the methods
          defined for those types of service. For example, we can see that the
          <methodname>hideEmailAddress</methodname> method makes a call (via
          <methodname>employeeIsCurrentUser</methodname>) to the
          <classname>UserFinder</classname> service:</para>

          <programlisting format="linespecific">public boolean hideEmailAddress() {
    return !employeeIsCurrentUser();
}

private boolean employeeIsCurrentUser() {
    return getUserFinder().currentUserAsObject() == this;
}</programlisting>
        </sect2>

        <sect2>
          <title>Making services directly accessible to the user</title>

          <para>Services may be made available directly to the user. On the
          DND user interface these appear as the large icons on the desktop;
          on the HTML user interface (that is, as styled by the default CSS)
          these appear as the tabs across the top of the screen. Which
          services are made available to a particular user are defined in
          'perspectives' within a user profile. Within the Fixture project the
          class <classname>ExplorationUserProfileFixture</classname> defines
          the perspectives for various defined prototype users:</para>

          <programlisting format="linespecific">public class ExplorationUserProfileFixture extends UserProfileFixture {

    @Override
    protected void installProfiles() {
        ...
        Profile svenProfile = newUserProfile();
        Perspective claimsPerspective = svenProfile.newPerspective("Claims");
        claimsPerspective.addToServices(Claims.class);
        claimsPerspective.addToServices(Employees.class);
        saveForUser("sven", svenProfile);
        ...

    }
}</programlisting>

          <para>The above example specifies that the user 'sven' is to be
          given a perspective called 'Claims', which gives him direct access
          to two services: <classname>ClaimStartPoints</classname> and
          <classname>EmployeeStartPoints</classname>. If we look at the second
          of those, we can see that it defines two actions:
          <methodname>findEmployeeByName</methodname> and
          <methodname>me</methodname>:</para>

          <programlisting format="linespecific">  @Named("Employees")
  public class EmployeeStartPoints extends AbstractService {
      // {{ Title &amp; ID

      // {{ Injected Services

      @MemberOrder(sequence = "2")
      public List&lt;Employee&gt; findEmployeeByName(@Named("Name (or start of Name)")
      final String name) {
          List&lt;Employee&gt; results = employeeRepository.findEmployeeByName(name);
          if (results.isEmpty()) {
              warnUser("No employees found matching name: " + name);
              return null;
          }
          return results;
      }

      @Executed(Executed.Where.LOCALLY)
      public Employee me() {
          Employee me = employeeRepository.me();
          if (me == null) {
              warnUser("No Employee representing current user");
          }
          return me;
      }
  }</programlisting>

          <para>Both of these methods delegate to methods on the
          <classname>EmployeeRepository</classname>, which has been injected
          (services may be injected into other services, just as into domain
          objects). Note that it is not necessary to define specific services
          to be provided directly to the user - we could provide the user with
          direct access to the Repositories, Factories or other services
          specified within the application. Creating dedicated user-oriented
          service definitions just helps us to separate the concerns. Calling
          them 'Start Points' is also just a convention.</para>
        </sect2>

        <sect2>
          <title>Using services to contribute actions to domain
          objects</title>

          <para>The screens below show the action menu on the Claim object, as
          rendered by the two different user interfaces:</para>

          <screenshot>
            <mediaobject>
              <imageobject>
                <imagedata align="center" contentwidth="40%"
                           fileref="images/claim-contributed-actions.png"
                           format="PNG" />
              </imageobject>
            </mediaobject>
          </screenshot>

          <para>This menu has a sub-menu, entitled 'Recorded Actions',
          containing, in this case, a single method 'All Recorded Actions'.
          Sub-menus in Naked Objects are 'contributed' by services; the
          actions in the sub-menus are described as 'contributed actions'. In
          this case the actions are contributed the service
          <classname>RecordedActionContributedActions</classname>:</para>

          <programlisting format="linespecific">  @Named("Recorded Actions")
  public class RecordedActionContributedActions extends AbstractService {

      // {{ Injected Services
 
      public List&lt;RecordedAction&gt; allRecordedActions(RecordedActionContext context) {
          return recordedActionRepository.allRecordedActions(context);
      }
  }</programlisting>

          <para>The method <methodname>allRecordedActions</methodname> takes a
          <classname>RecordedActionContext</classname> as a parameter, and
          will return all the <classname>RecordedAction</classname>s
          associated with that object. Note that
          <classname>RecordedActionContext</classname> is an interface that
          defines no methods - it is purely a type definition:</para>

          <programlisting format="linespecific">public interface RecordedActionContext {
}</programlisting>

          <para>However, this interface is implemented by two classes:
          <classname>Employee</classname> and <classname>Claim</classname>.
          The net result of this is that the action 'All Recorded Actions'
          will be contributed to each instance of
          <classname>Employee</classname> and of <classname>Claim</classname>.
          By default, this would appear in a sub-menu named after the service
          on which the method was defined (i.e. 'Recorded Action Contributed
          Actions'), but in this case we have used the <literal
          moreinfo="none">@Named</literal> annotation to override this and
          render the service name, and hence the sub-menu name, simply as
          'Recorded Actions'.</para>

          <para>We can also see that this method delegates its execution to
          the <classname>RecordedActionRepository</classname>, which has been
          injected as a service. You are not required to follow this pattern,
          or this naming convention. In fact, if the
          <methodname>allRecordedActions</methodname> method on
          <classname>RecordedActionRepository</classname> was not
          <classname>@Hidden</classname>, then it would have been contributed
          automatically - without the need for defining
          <classname>RecordedActionContributedActions</classname>. We have
          defined the latter purely to help convey intent and manage our code
          base.</para>

          <para>The rule is that any method defined on any service that the
          user is authorised to access (see <xref linkend="authorization" />)
          and is not hidden, will be contributed to any object of a type that
          features as any of the parameters to that method.</para>

          <para>This is a very powerful feature of Naked Objects, but it is
          one that takes a bit of getting used to. In some respects it is a
          little bit like Aspect Oriented Programming (AOP), in that it allows
          an object effectively to inherit capabilities from several different
          sources. However, this all takes place at run-time, not at compile
          time.</para>

          <para>In a more complex application, it might well be that a domain
          object might have several contributed sub-menus, each containing
          several methods. Designing an application this way allows us to keep
          the model well partitioned. In this very simple example, it has
          allowed us to keep the part of the model concerned with recording
          actions very separate from the other parts of the model.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Fixtures</title>

        <para>Fixtures are used to set up objects within the code based,
        principally for use within prototyping and or testing. Naked Objects
        provides specific support for using fixtures. The following code shows
        a fixture class that sets up one claim:</para>

        <programlisting format="linespecific">public class SvenClaim1NewStatus extends AbstractClaimFixture {
    
    public static Employee SVEN;
    public static Employee DICK;
    public static Claim SVEN_CLAIM_1;

    @Override
    public void install() {
        SVEN = EmployeeFixture.SVEN;
        DICK = EmployeeFixture.DICK;

        SVEN_CLAIM_1 =createNewClaim(SVEN, DICK, "28th Mar - Sales call, London", ProjectCodeFixture.CODE1, new Date(2007,4,3));
        Date mar28th = new Date(2007,3,28);
        addTaxi(SVEN_CLAIM_1, mar28th, null, 8.50, "Euston", "Mayfair", false);
        addMeal(SVEN_CLAIM_1, mar28th, "Lunch with client", 31.90);
        addTaxi(SVEN_CLAIM_1, mar28th, null, 11.00, "Mayfair", "City", false);
    } 
}</programlisting>

        <para>This inherits from <classname>AbstractClaimFixture</classname>,
        which provides the helper methods such as
        <methodname>createNewClaim</methodname>, and which inherits in turn
        from <classname>AbstractFixture</classname>, a class in the Naked
        Objects application library. However, there is no need to follow this
        pattern: a fixture may be any class that has an
        <methodname>install</methodname> method.</para>

        <para>Fixtures may be composite, as we can see in this example:</para>

        <programlisting format="linespecific">public class SvenClaims_All extends AbstractClaimFixture {
    
    public SvenClaims_All() {
        addFixture(new SvenClaim1NewStatus());
        addFixture(new SvenClaim2Submitted());
        addFixture(new SvenClaim5New());
        addFixture(new SvenClaim3Returned());
        addFixture(new SvenClaim4Approved());
    }  
    
    public void install() {}
}</programlisting>

        <para>This fixture has had five other fixtures added to it. The
        <methodname>install</methodname> method is empty: Naked Objects will
        automatically call <methodname>install</methodname> on each of the
        fixtures that has been added to this composite fixture. This pattern
        makes it easy to manage large fixtures, and multiple sets of
        (potentially overlapping) fixtures, both for prototyping and for
        testing.</para>

        <para>As with services, Naked Objects needs to be instructed which
        fixtures it should use when running an application. This may be done
        in the properties files, for example:</para>

        <programlisting format="linespecific">nakedobjects.fixtures.prefix=org.nakedobjects.example.expenses.fixtures
nakedobjects.fixtures=ExplorationPerspectiveFixture, RefdataFixture, EmployeeFixture,  SvenClaims_All</programlisting>

        <para>Note that this also specifies the
        <classname>ExplorationPerspectiveFixture</classname>, which we looked
        at earlier.</para>

        <para>Fixtures may also be specified as a command line parameter (see
        <xref linkend="command-line-parameters" />) when launching the
        application from the command line; composite fixtures are especially
        handy in this circumstance.</para>
      </sect1>
    </chapter>
  </part>

  <part id="app-dev-guide">
    <title>Application Development</title>

    <chapter>
      <title>Installing Naked Objects</title>

      <sect1>
        <title>Preparing to develop with Naked Objects</title>

        <para>Like all Java frameworks Naked Objects is essentially a set of
        classes and other resources that you run your code with. There are a
        number of ways of developing with Naked Objects: downloading a
        traditional distribution and installing it on your machine; or using
        Maven to create and manage your Naked Object projects. Which you
        choose is a matter of preference and familiarity.</para>
      </sect1>

      <sect1>
        <title>Prerequisites</title>

        <para>To develop or run Naked Objects applications you need Java
        version 1.5 or above installed on your machine.</para>

        <para>To build and run the examples you will also need either <ulink
        url="http://ant.apache.org/">Ant</ulink> or <ulink
        url="http://maven.apache.org">Maven</ulink> installed, both available
        from Apache.</para>

        <para>To develop applications you will need a suitable development
        environment. If you have the choice, we recommend using <ulink
        url="www.eclipse.org">Eclipse</ulink>, because there are some specific
        plug-ins available for Eclipse to facilitate developing with Naked
        Objects. However, Naked Objects may be used with any IDE, or even just
        the JDK.</para>

        <para>The next two sections look at downloading and installing Naked
        Objects.</para>
      </sect1>

      <sect1>
        <title>Downloading a distribution</title>

        <para>The latest version of the Naked Objects framework can be
        downloaded from the downloads page of the <ulink
        url="http://sourceforge.net/projects/nakedobjects/">Naked Objects
        Sourceforge project</ulink> as shown below. You may download either
        the Ant release (suffixed with '-for-ant' ), the Maven release
        (suffixed with '-for-maven'), the full source release (suffixed with
        '-source' ) if you wish to build the framework yourself, or simply a
        jar file that bundles in all the dependencies but has no documentation
        or other resources.</para>

        <para><remark>TODO: update the following screenshot</remark></para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata align="center" contentwidth="40%"
                         fileref="images/downloads.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <sect2>
          <title>Installing a Naked Objects distribution</title>

          <para>Extract the downloaded file's content into a suitable
          directory (a root directory is created upon extraction so there is
          no need to create a directory in which to install
          everything).</para>

          <sect3>
            <title>The '-for-ant' binary release</title>

            <para>The binary release for Ant provides the following
            directories and files:-</para>

            <itemizedlist>
              <listitem>
                <para>a set of jar files making up the Naked Objects
                framework, and other third party jars required by the
                framework (in <filename class="directory"
                moreinfo="none">lib/</filename>)</para>
              </listitem>

              <listitem>
                <para>one or more demo applications that may be run from the
                command line (in <filename class="directory"
                moreinfo="none">demos/</filename>)</para>
              </listitem>

              <listitem>
                <para>one or more example applications that may be edited,
                compiled and run via Ant (in <filename class="directory"
                moreinfo="none">examples/</filename>)</para>
              </listitem>

              <listitem>
                <para>documentation (in <filename class="directory"
                moreinfo="none">docs/</filename>)</para>
              </listitem>

              <listitem>
                <para>a <filename class="directory"
                moreinfo="none">resource</filename> directory with icon images
                and templates</para>
              </listitem>
            </itemizedlist>

            <para>For more details on developing using Ant, see <xref
            linkend="building_with_ant" />.</para>
          </sect3>

          <sect3>
            <title>The '-for-maven' Binary release</title>

            <para>The binary release for Maven contains supporting resources
            (including icons, examples and this documentation). It does not
            include the Naked Objects libraries themselves however, because
            Maven itself downloads them from the Maven central
            repository.</para>

            <para>The distribution contains following directories and
            files:-</para>

            <itemizedlist>
              <listitem>
                <para>one or more example applications that may be edited,
                compiled and run via Maven (in <filename class="directory"
                moreinfo="none">examples/</filename>)</para>
              </listitem>

              <listitem>
                <para>documentation (in <filename class="directory"
                moreinfo="none">docs/</filename>)</para>
              </listitem>

              <listitem>
                <para>a <filename class="directory"
                moreinfo="none">resource</filename> directory with icon
                images</para>
              </listitem>
            </itemizedlist>

            <para>Because the Maven distribution does not include the
            libraries, there is no immediately runnable demo. However as
            indicated above the examples are still there and can be built
            using Maven (or imported into an Eclipse or other IDE and built
            there).</para>

            <para>For more details on developing using Maven, see <xref
            linkend="building_with_maven" />.</para>
          </sect3>

          <sect3>
            <title>Source release</title>

            <para>The source release contains a series of directories, which
            are Eclipse projects, for the different subcomponents of Naked
            Objects, the libs and examples. This source can be used, with the
            templates in the build directories, to recreate the distributions
            made publicly available.</para>

            <para>To install all the components into your local repository,
            and generate the distribution files, first build the parent
            project POM and then build the framework itself:</para>

            <screen>$ <emphasis role="bold">cd nakedobjects-4.0 </emphasis>
$ cd pom
$ mvn clean install
$ cd ..
$ <emphasis role="bold">mvn clean install -P all </emphasis>
</screen>

            <para>Any missing resources that maven complains about are can be
            installed into the repository by specifying the specific jar file
            from the lib directory when following the instructions that Maven
            gives you.</para>

            <para>Using the source release Maven will build the same files
            that you would download if you had downloaded a binary version.
            The distribution files (as detailed for the binary release above)
            are to be found within the directory <filename class="directory"
            moreinfo="none">distribution/tarball/target</filename> as shown
            below.</para>

            <screen>distribution/
|-- docexamples
|-- documentation
|-- pom.xml
|-- tarball
|   |-- pom.xml
|   |-- src
|   `-- target
|       |-- archive-tmp
|       |-- maven-archiver
|       |-- <emphasis>nakedobjects-4.0-beta-3-SNAPSHOT-for-ant.tar.gz</emphasis>
|       |-- <emphasis>nakedobjects-4.0-beta-3-SNAPSHOT-for-ant.zip</emphasis>
|       |-- <emphasis>nakedobjects-4.0-beta-3-SNAPSHOT-for-maven.tar.gz</emphasis>
|       |-- <emphasis>nakedobjects-4.0-beta-3-SNAPSHOT-for-maven.zip</emphasis>
|       |-- <emphasis>nakedobjects-4.0-beta-3-SNAPSHOT-source.zip</emphasis>
|       `-- <emphasis>nakedobjects-4.0-beta-3-SNAPSHOT-libs-only-with-dependencies.jar</emphasis>
`-- target</screen>

            <para>With the core libraries and plugins build, the final step is
            to install the archetype so that new projects can be created from
            the local archetype, rather then the publicly available
            one.</para>

            <screen>$ <emphasis role="bold">cd archetypes/application </emphasis>
$ <emphasis role="bold">mvn clean install</emphasis></screen>
          </sect3>

          <sect3>
            <title>Jar release</title>

            <para>A final option is to use the jar of jars. This is a single
            jar file that contains all the other jars. This allows you
            simplify your projects by simply having that one jar on your
            classpath. However, this leaves you to set up your projects from
            scratch.</para>

            <para>This release is often useful later, however, when you have
            created an application and wish to distribute your own way.</para>
          </sect3>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title>Developing domain objects - a how-to guide</title>

      <para>This section defines a set of conventions for writing domain
      objects, that are together known as the 'Naked Objects (Java)
      Programming Model'.</para>

      <para>Following these conventions does not tie your domain objects to
      the Naked Objects Framework or any other framework: the resulting domain
      objects may be run within any framework or platform that supports POJOs
      (Plain Old Java Objects). A few of the conventions do make use of
      Interfaces or Annotations that are necessarily defined somewhere - in
      this case they are in the Naked Objects AppLib. However, the AppLib is
      not itself dependent upon the Naked Objects Framework (and in theory
      another framework implementation could support the same applib).</para>

      <para>The conventions of the programming model are best described as
      'intentional' - they convey an intention as to how domain objects, their
      properties and behaviours, are to be made available to users. The
      specific way in which those intentions are interpreted or implemented
      will depend upon the framework, and/or the particular components or
      options selected within that framework.</para>

      <para>To pick a single example, marking up a domain class with the
      annotation <code>@Bounded</code> is an indication that the class is
      intended to have only a small number of instances and that the set does
      not change very often - such as the class <code>Country</code>. This is
      an indication to any interested framework that the whole set of
      instances might be offered to the user in a convenient form such as a
      drop-down list. The programming convention has <emphasis>not</emphasis>
      been defined as <code>@DropDownList</code> because the user interface
      might not support drop-down-lists - but it might provide a capability to
      select from an <code>@Bounded</code> class by typing the initial letters
      of the desired instance.</para>

      <sect1>
        <title>Object-level specifications</title>

        <para>The first set of conventions are concerned with the capabilities
        or behaviour of an object as a whole.</para>

        <sect2>
          <title condition="java">How to specify a title for an object</title>

          <para>A title is used to identify an object to the user in the user
          interface. For example, a Customer's title might be the
          organization's customer reference, or perhaps (more informally)
          their first and last names. By default, the framework will use the
          object's <literal moreinfo="none">toString()</literal> method as the
          title. However, if a <literal moreinfo="none">title()
          </literal>method (returning a <literal
          moreinfo="none">String</literal>) is present, then that is used
          instead, thus:</para>

          <para><programlisting>public String toString()</programlisting></para>

          <para>or</para>

          <para><programlisting>public String title()</programlisting></para>

          <para>The reason for providing the option to use a <literal
          moreinfo="none">title</literal> method is in case the programmer
          needs to make use of the <literal moreinfo="none">toString</literal>
          method for other purposes, such as for debugging.</para>
        </sect2>

        <sect2>
          <title condition=".net">How to specify the icon for an
          object</title>

          <para condition="1.5">By default, the framework will look for an
          image in the <filename class="directory"
          moreinfo="none">images</filename> directory (which must be on the
          classpath) that has the same name as the object class. So for an
          object of type Customer, it will look for <filename
          class="directory" moreinfo="none">Customer.gif</filename> or
          <filename class="directory" moreinfo="none">Customer.png</filename>.
          If it finds no such file, then it will work up the inheritance
          hierarchy to see if there is an icon matching the name of any of the
          super-classes, and use that instead. If no matching icon is found
          then the framework will look for an image called <filename
          class="directory" moreinfo="none">default</filename> in the images
          directory, and if this has not been specified, then the framework
          will use its own default image for an icon.</para>

          <para>We strongly recommend that you adopt 'camel case' as the
          convention for icon file names: if you have a class called
          <classname condition="vb"> OrderLine</classname>, then call the icon
          <filename class="directory" moreinfo="none">OrderLine.gif</filename>
          or <filename class="directory"
          moreinfo="none">OrderLine.png</filename> (JPEG suffixes
          <filename>OrderLine.jpg</filename> or
          <filename>OrderLine.jpeg</filename> will also be recognized but
          generally GIF or PNG are to be preferred). Actually, the framework
          will also recognise <filename class="directory"
          moreinfo="none">orderline.gif</filename>, but some operating systems
          and deployment environments are case sensitive, so it is good
          practice to adopt an unambiguous convention.</para>

          <para>The programmer may choose to specify, manually, which icon to
          use, by specifying an <literal moreinfo="none">iconName</literal>
          method:</para>

          <programlisting format="linespecific">    public String iconName() {
        return "Person";
    }</programlisting>

          <para>This makes it easy for more than one class to use the same
          icon, without having to duplicate the image file.</para>

          <para>The <code>iconName</code> method may also be used to specify
          an individual icon for each instance. For example, an instance of
          <classname>Product</classname> could use a photograph of the product
          as an icon, using:</para>

          <programlisting format="linespecific">    public String iconName() {
        return getProductName() + "-photograph";
    }</programlisting>

          <para>or to vary the icon according to the status of the
          object:<programlisting>    public String iconName() {
        return "Order-" + getStatus();
    }</programlisting></para>
        </sect2>

        <sect2>
          <title condition="j#">How to specify a name and/or description for
          an object</title>

          <para>By default, the name (or type) of an object, as displayed to
          the user will be the class name. However, if an <literal
          moreinfo="none">@Named</literal> annotation is included, then this
          will override the default name. This might be used to include
          punctuation or other characters that may not be used within a class
          name.</para>

          <para>By default the framework will create a plural version of the
          object name by adding an 's' to singular name, or a 'ies' to names
          ending 'y'. For irregular nouns or other special case, the
          <code>@Plural</code> annotation may be used to specify the plural
          form of the name explicitly.</para>

          <para>(Note that there is an entirely separate mechanism for dealing
          with Internationalisation, which is described elsewhere).</para>

          <para>The programmer may optionally also provide a <literal
          moreinfo="none">@DescribedAs</literal> annotations, containing a
          brief description of the object's purpose, from a user perspective.
          The framework will make this available to the user in a form
          appropriate to the user interface style - for example as 'balloon'
          help.</para>
        </sect2>

        <sect2>
          <title condition="vb">How to specify that an object should not be
          persisted</title>

          <para>Use the <literal moreinfo="none">@NotPersistable</literal>
          annotation.</para>
        </sect2>

        <sect2>
          <title>How to specify that an object should never be modified by the
          user</title>

          <para>Use the <literal moreinfo="none">@Immutable</literal>
          annotation.</para>
        </sect2>

        <sect2>
          <title>How to specify that a class of objects has a limited number
          of instances</title>

          <para>Use the <literal moreinfo="none">@Bounded</literal>
          annotation. A common way of describing this is that the whole
          (limited) set of instances may be rendered to the user as a drop
          down list - but the actual interpretation will depend upon the form
          of the user interface.</para>
        </sect2>

        <sect2>
          <title>How to specify that an object should always be hidden from
          the user</title>

          <para>Use the <literal moreinfo="none">@Hidden</literal>
          annotation.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>The object lifecycle</title>

        <para>These conventions are concerned with the creation, retrieval,
        updating and deletion of objects.</para>

        <sect2>
          <title>How to create or delete objects within your code</title>

          <para>When you create any domain object within your application
          code, it is important that the framework is made aware of the
          existence of this new object - in order that it may be persisted to
          the object store, and in order that any services that the new object
          needs are injected into it. Just specifying <literal
          moreinfo="none">new Customer()</literal>, for example, will create a
          Customer object, but that object will <emphasis>not</emphasis> be
          known to the framework. However, since we do not want to tie our
          domain objects to a particular framework, we use the idea of a
          'container' to intermediate. The application library provides an
          interface:</para>

          <para><literal
          moreinfo="none">org.nakedobject.applib.DomainObjectContainer</literal>
          which in turn defines the following methods for managing domain
          objects:</para>

          <para><literal moreinfo="none">&lt;T&gt; T
          newTransientInstance(final Class&lt;T&gt; ofClass)</literal> returns
          a new instance of the specified class, that is transient (unsaved).
          This may subsequently saved either by the user invoking the Save
          action (that will automatically be rendered on the object view) or
          programmatically by calling <literal moreinfo="none">void
          makePersistent(Object transientObject)</literal></para>

          <para><literal moreinfo="none">&lt;T&gt; T
          newPersistentInstance(final Class&lt;T&gt; ofClass)</literal>
          creates a new object already persisted.</para>

          <para><literal moreinfo="none">boolean
          isPersistent()</literal>checks whether an object has already been
          persisted. (Useful in controlling visibility or availability of
          properties or actions).</para>

          <para><literal moreinfo="none">void remove(Object object)</literal>
          deletes a persistent object from the object store.</para>

          <para>Any framework that recognises the Naked Objects Programming
          Model will provide an implementation of
          <code>DomainObjectContainer</code> and will take responsibility to
          inject a reference to that Container into any domain object that
          needs it.</para>

          <para>A domain object specifies that it needs to have a reference to
          the Container injected into by including the following code:</para>

          <programlisting format="linespecific">    private DomainObjectContainer container;

    protected DomainObjectContainer getContainer() {
        return this.container;
    }
    public final void setContainer(final DomainObjectContainer container) {
        this.container = container;
    }</programlisting>

          <para>Creating or deleting objects is then done by invoking those
          methods on the Container. For example the following code would then
          create a new Customer object within another method:</para>

          <programlisting format="linespecific">    Customer newCust = (Customer) getContainer().newTransientInstance(Customer.class);
    newCust.setName("Charlie");
    getContainer().persist(newCust);</programlisting>

          <para>If you are able to make your domain object inherit from
          <literal
          moreinfo="none">org.nakedobjects.applib.AbstractDomainObject</literal>
          then you have direct access to those methods, so the code would
          become:</para>

          <programlisting format="linespecific">    Customer newCust = (Customer) newTransientInstance(Customer.class);
    newCust.setName("Charlie");
    persist(newCust);</programlisting>

          <para>These methods are actually provided by the
          <classname>org.nakedobjects.applib.AbstractContainedObject</classname>
          and so are also available on <literal
          moreinfo="none">org.nakedobjects.applib.AbstractService</literal>
          (and, hence, on <literal
          moreinfo="none">org.nakedobjects.applib.AbstractFactoryAndRepository</literal>)
          for creating objects within a service.</para>

          <warning>
            <para>It is possible to create a transient object within another
            transient object. When the framework persists any transient
            object, it will automatically persist any other transient object
            referenced by that object. However, if any of these transient
            objects are to be exposed to the user (while in their transient
            state), then you need to write your code very carefully -
            anticipating the fact that the user could elect to save any of the
            transient objects at any point - which could cause the graph of
            related objects to be persisted in an invalid state.</para>

            <para>The recommended approach is, if possible, to mark these
            supplementary classes as not persistable by the user (see <xref
            linkend="not-persistable" />), or not to permit the user to create
            a new transient object that is a child of an existing transient
            object, but, rather, to require the user to save the parent object
            first.</para>
          </warning>
        </sect2>

        <sect2>
          <title>How to insert behaviour into the object life cycle</title>

          <para>The following is a list of methods that correspond to various
          events in the life-cycle of a domain object. If a domain object
          implements any of these methods (they are all optional) then the
          framework will call that method whenever the corresponding event
          occurs. For example, <literal
          moreinfo="none"><methodname>persisted</methodname></literal> is
          called after an object has been persisted. One reason for
          implementing the <literal
          moreinfo="none"><methodname>persisted</methodname></literal> method
          might be to set up a reverse association that we do not want to be
          set up until the new object has been persisted.</para>

          <para><literal moreinfo="none">public void created() </literal>will
          be called by the framework at logical creation of the object</para>

          <para><literal moreinfo="none">public void loading()</literal> will
          be called by the framework when a persistent object is about to be
          loaded into memory</para>

          <para><literal moreinfo="none">public void loaded()</literal> will
          be called by the framework when a persistent object has just been
          loaded into memory</para>

          <para><literal moreinfo="none">public void persisting()
          </literal>will be called by the framework just before a transient
          object is first persisted. (For backwards compatibility
          <methodname>saving()</methodname> is also supported).</para>

          <para><literal moreinfo="none">public void persisted() </literal>
          will be called by the framework just after a transient object is
          first persisted. (For backwards compatibility
          <methodname>saved()</methodname> is also supported).</para>

          <para><literal moreinfo="none">public void updating() </literal>will
          be called by the framework after any property on a persistent object
          has been changed and just before this change is persisted</para>

          <para><literal moreinfo="none">public void updated() </literal>will
          be called by the framework just after a changed property on a
          persistent object has been persisted</para>

          <para><literal moreinfo="none">public void removing()</literal> will
          be called by the framework when a persistent object is just about to
          be deleted from the persistent object store. (For backwards
          compatibility <methodname>deleting()</methodname> is also
          supported).</para>

          <para><literal moreinfo="none">public void removed()</literal> will
          be called by the framework when a persistent object has just been
          deleted from the persistent object store. (For backwards
          compatibility <methodname>deleted()</methodname> is also
          supported).</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Properties</title>

        <para>The following conventions are concerned with specifying the
        properties of an object, and the way in which users can interact with
        those properties.</para>

        <sect2>
          <title>How to add a property to an object</title>

          <para>Properties are specified using the JavaBean conventions,
          recognizing a standard accessor/mutator pair (<code>get</code> and
          <code>set</code>). The syntax is:</para>

          <para><programlisting>public &lt;property type&gt; get&lt;PropertyName&gt;() 

public void set&lt;PropertyName&gt;(&lt;property type&gt; param)</programlisting></para>

          <para>where <literal moreinfo="none">&lt;property type&gt;</literal>
          is a primitive, a value object or an entity object.</para>

          <para>Properties may reference either a value or another domain
          object. Values include Java primitives, and JDK classes with value
          semantics (<literal moreinfo="none">java.lang.Strings</literal> and
          <literal moreinfo="none">java.util.Dates</literal>). A property
          referencing another domain object is sometimes called an
          association.</para>

          <para>For example, the following example contains both a value
          (<literal moreinfo="none">String</literal>) property and a reference
          (<literal moreinfo="none">Organisation</literal>) property:</para>

          <programlisting format="linespecific">public class Customer {
    private String firstName;
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    private Organisation organisation;
    public Organisation getOrganisation() {
        return organisation;
    }
    public void setOrganisation(Organisation organisation) { 
        this.organisation = organisation;
    }

    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>How to prevent the user from modifying a property</title>

          <para>Preventing the user from modifying a property value is known
          as 'disabling' the property.</para>

          <sect3>
            <title>Disabling a property always</title>

            <para>Use the <literal moreinfo="none">@Disabled</literal>
            annotation.</para>
          </sect3>

          <sect3>
            <title>Disabling a property under certain conditions</title>

            <para>A <literal moreinfo="none">disable</literal> method can be
            used to disable a particular instance's member under certain
            conditions. The syntax is:</para>

            <para><literal moreinfo="none">public String
            disable&lt;PropertyName&gt;()</literal> A non-null return value
            indicates the reason why the property cannot be modified. The
            framework is responsible for providing this feedback to the user.
            For example:</para>

            <programlisting format="linespecific">public class OrderLine {
    public String getQuantity() { ... }
    public void setQuantity(int quantity) { ... }

    public String disableFirstName() { 
        if (this.hasBeenSubmitted()) {
            return "Cannot alter any quantity after Order has been submitted"; 
        }
        return null;
    }
}</programlisting>
          </sect3>

          <sect3>
            <title>Disabling a property for specific users or roles</title>

            <para>Generally it is not good practice to embed knowledge of
            roles and/or users into the domain classes. This is the
            responsibility of the framework or platform and should be
            specified and administered externally to the domain model.</para>

            <para>However, in rare circumstances it might be necessary or
            pragmatic to implement access control within the domain model
            using the inherited <methodname>getUser()</methodname>
            method:</para>

            <para>For example:</para>

            <programlisting format="linespecific">import org.nakedobjects.applib.UserMemento;

public class Employee {
    public BigDecimal getSalary() { ... }
    public void setSalary(BigDecimal salary) { ... }

    public String validateSalary(BigDecimal salary) {
        return salary.doubleValue() &gt;= 30000 &amp;&amp;
              !getUser().hasRole("MODIFY_SALARY")?
              "Need MODIFY_SALARY role to increase salary above 30000": null;
    }
}</programlisting>
          </sect3>
        </sect2>

        <sect2>
          <title>How to make a property optional (when saving an
          object)</title>

          <para>By default, when a new transient (unsaved) object is presented
          to the user, values must be specified for all properties before the
          object may be saved. To specify that a particular property is
          optional, use the <literal moreinfo="none">@Optional</literal>
          annotation.</para>
        </sect2>

        <sect2>
          <title>How to specify the size of String properties</title>

          <para>Use the <literal moreinfo="none">@MaxLength</literal>,
          <literal moreinfo="none">@TypicalLength</literal> and <literal
          moreinfo="none">@MultiLine</literal> annotations.</para>
        </sect2>

        <sect2>
          <title>How to validate user input to a property</title>

          <para>A <literal moreinfo="none">validate</literal> method is used
          to check that a new value for a property is valid. If the proffered
          value is deemed to be invalid then the property will not be changed.
          A non-null return <code>String</code> indicates the reason why the
          member cannot be modified/action be invoked; the framework is
          responsible for providing this feedback to the user.</para>

          <para>The syntax is:</para>

          <para><programlisting>public String validate&lt;PropertyName&gt;(&lt;property type&gt; param)</programlisting></para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Exam {
    public int getMark() { ... }
    public void setMark(int mark) { ... }
    public validateMark(int mark) {
        return !(mark &gt;= 0 &amp;&amp; mark &lt;= 30)?
            "Mark must be in range 0 to 30"
            :null;
    }
}</programlisting>

          <sect3>
            <title>Format validation</title>

            <para>For properties that accept a text input string, such as
            <code>String</code> and <code>Date</code>, there are convenient
            mechanisms to validate and/or normalise the values typed
            in.</para>

            <para>For <literal moreinfo="none">Date</literal> and number
            values the <literal moreinfo="none">@Mask</literal> annotation may
            be used.</para>

            <para>For <literal moreinfo="none">String</literal> properties the
            <literal moreinfo="none">@RegEx</literal> annotation may be
            used.</para>
          </sect3>
        </sect2>

        <sect2>
          <title>How to specify a set of choices and or a default value for a
          property</title>

          <para>The simplest way to provide the user with a set of choices for
          a property (possibly rendered as a drop-down list, for example) is
          to ensure that the type used by the property is marked up as
          <code>@Bounded</code>. However, this is not always appropriate. For
          example you might wish to provide the user with the choice of all
          the Addresses known for that Customer, with the most recently-used
          address as the default.</para>

          <para>The syntax for specifying a default value is:</para>

          <para><programlisting>public &lt;property type&gt; default&lt;PropertyName&gt;()</programlisting></para>

          <para>And for specifying a list of choices is:</para>

          <para><programlisting>public &lt;array or collection of property type&gt; choices&lt;PropertyName&gt;()</programlisting></para>

          <para>The full code for our example above is:</para>

          <programlisting format="linespecific">public class Order {
    public Address getShippingAddress() { ... }
    public void setShippingAddress() { ... }
    public Address defaultShippingAddress() {
        return getCustomer().normalAddress();
    }
    public List&lt;Address&gt; choicesShippingAddress() {
        return getCustomer().allActiveAddresses();
    }
}</programlisting>
        </sect2>

        <sect2>
          <title>How to set up the initial value of a property
          programmatically</title>

          <para>Initial values for properties may be set up programmatically
          within the <literal moreinfo="none">created()</literal> method on
          the object. (See Object: Life Cycle).</para>
        </sect2>

        <sect2>
          <title>How to trigger other behaviour when a property is
          changed</title>

          <para>If you want to invoke functionality whenever a property is
          changed by the user, then you should create a <literal
          moreinfo="none">modify</literal> <literal
          moreinfo="none">&lt;propertyName&gt;</literal> and include the
          functionality within that. For example:</para>

          <programlisting format="linespecific">public int getAmount() {}
public void setAmount(int amount) {}

public void modifyAmount(int amount) {
     setAmount(amount);
     addToTotal(amount);
}</programlisting>

          <para>The reason for the <literal
          moreinfo="none">modifyAmount</literal> method is that it would not
          be a good idea to include the <literal
          moreinfo="none">addToTotal</literal> call within the <literal
          moreinfo="none">setAmount</literal> method , because that method may
          be called by the persistence mechanism when an object is retrieved
          from storage.</para>

          <para>You may optionally also specify a
          <code>clear&lt;PropertyName&gt;</code> which works the same way as
          modify <literal moreinfo="none">modify</literal> <literal
          moreinfo="none">&lt;propertyName&gt;</literal> but is called when
          the property is cleared by the user (i.e. the current value replaced
          by nothing).</para>

          <para>These methods may also be used for setting up bidirectional
          relationships (using the 'mutual registration pattern'). For
          example:</para>

          <programlisting format="linespecific">public class Employee {
    private Department department;
    public Department getDepartment() {
        return department;
    }
    public void setDepartment(Department department) { 
        this.department = department;
    }
    public void modifyDepartment(Department department) {
        setDepartment(department);
        department.addToStaff(this);
    }
    public void clearDepartment(Department department) {
        setDepartment(null);
        department.removeFromStaff(this);
    }

    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>How to control the order in which properties are
          displayed</title>

          <para>Use the <literal moreinfo="none">@MemberOrder</literal>
          annotation.</para>
        </sect2>

        <sect2>
          <title>How to specify a name and/or description for a
          property</title>

          <sect3>
            <title>Specifying the name for a property</title>

            <para>By default the framework will use the property name itself
            to label the property on the user interface. If you wish to
            over-ride this, use the <literal moreinfo="none">@Named
            </literal>annotation on the property.</para>
          </sect3>

          <sect3>
            <title>Specifying a description for a property</title>

            <para>Use the <literal moreinfo="none">@DescribedAs</literal>
            annotation on the property itself.</para>

            <para>The framework will take responsibility to make this
            description available to the user, for example in the form of a
            'balloon help'.</para>
          </sect3>
        </sect2>

        <sect2>
          <title>How to hide a property from the user</title>

          <sect3>
            <title>Hiding a property always</title>

            <para>Use the <literal moreinfo="none">@Hidden</literal>
            annotation.</para>
          </sect3>

          <sect3>
            <title>Hiding a property under certain conditions</title>

            <para>A <literal moreinfo="none">hide</literal> method can be used
            to indicate that a particular instance's member should be hidden
            (rendered invisible to the user) under certain conditions. The
            syntax is:</para>

            <para><literal moreinfo="none">public boolean
            hide&lt;PropertyName&gt;()</literal> A true return value indicates
            that the property is hidden. For example:</para>

            <programlisting format="linespecific">public class Order {
    public String getShippingInstructions() { ... }
    public void setShippingInstructions(String shippingInstructions) { ... }
    public boolean hideShippingInstructions() {
        return hasShipped();
    }
}</programlisting>
          </sect3>

          <sect3>
            <title>Hiding a property for specific users or roles</title>

            <para><emphasis role="strong">Important</emphasis>: see the
            comments under 'Disabling a property for specific users or
            roles'.</para>

            <para>Session controls provide a way for the class to hide
            properties from specific users, or users not in specific roles.
            The syntax is: <literal moreinfo="none">public boolean
            hide&lt;PropertyName&gt;(Session session)</literal> For
            example:</para>

            <programlisting format="linespecific">public class Employee {
    public BigDecimal getSalary() { ... }
    public void setSalary(BigDecimal salary) { ... }
    public boolean hideSalary(UserMemento user, BigDecimal salary) {
        return !user.hasRole("VIEW_SALARY");
    }
}</programlisting>
          </sect3>
        </sect2>

        <sect2>
          <title>How to make a property non-persisted</title>

          <para>If there is no mutator (<code>set</code>) method then the
          field is not only unmodifiable but will also
          <emphasis>not</emphasis> be persisted. This approach is by design
          and also happens to be compatible with Java Persistence Api (JPA)
          semantics. This may be used to derive a property from other
          information available to the object, for example:</para>

          <programlisting format="linespecific">public class Employee {
    public Department getDepartment() { ... }
    public void setDepartment(Department department) { ... }
    public void modifyDepartment(Department department) { ... }
    public void clearDepartment(Department department) { ... }

    // this is the derived property
    public Employee getManager() {
        if (getDepartment() == null) { return null; }
        return getDepartment().getManager();
    }

    ...
}</programlisting>

          <para>If you need to have a <literal moreinfo="none">get</literal>
          and <literal moreinfo="none">set</literal> method for the property
          but do not wish to have that property persisted, use the <literal
          moreinfo="none">@NotPersisted</literal> annotation.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Actions</title>

        <para>An 'action' is a method that we expect the user to be able to
        invoke via the user interface, though it may also be invoked
        programmatically within the object model. The following conventions
        are used to determine when and how methods are made available to the
        user as actions.</para>

        <sect2>
          <title>How to add an action to an object</title>

          <para>By default, any <literal moreinfo="none">public</literal>
          instance method that you add to a class will be treated as a user
          action, unless it represents a property, collection, or another
          reserved method defined in this manual.</para>

          <para>If you have a method that you don't want to be made available
          as a user-action you should either make it <literal
          moreinfo="none">protected</literal> or <literal
          moreinfo="none">private</literal> or use the <literal
          moreinfo="none">@Hidden</literal> annotation. Note also that
          <literal moreinfo="none">static</literal> methods are ignored: such
          functionality should reside in a service, such as a Repository or
          Factory.</para>

          <para>We refer to all methods that are intended to be invoked by
          users as 'action methods'.</para>

          <para>The syntax is:</para>

          <para><programlisting>public void &lt;actionName&gt;([&lt;value or entity type&gt; param]...)</programlisting></para>

          <para>or</para>

          <para><programlisting>public &lt;return type&gt; &lt;actionName&gt;([&lt;value or entity type&gt; param]...)</programlisting></para>

          <para>When a method returns a reference the viewer will attempt to
          display that object. If the return value is <code>null</code> then
          nothing is displayed.</para>
        </sect2>

        <sect2>
          <title>How to specify parameters for an action</title>

          <para>If an action method takes parameters, the viewing mechanism
          will automatically require the user to specify these parameters (for
          example, in the form of a dialog box) - and ensure that they are of
          the correct type.</para>

          <sect3>
            <title>Specifying parameter names and/or descriptions</title>

            <para>Unlike with properties, the framework cannot pick up the
            names of parameters that you use within the domain code. By
            default parameters will be labelled only with the type of the
            object required (e.g. 'String:' or 'Customer:) If you want a
            parameter to have a different name (such as 'First Name', 'Last
            Name') then that parameter should be marked up with an <literal
            moreinfo="none">@Named</literal> annotation - very often taking
            the same form as the parameter name used in the code. (This is one
            of the few forms of duplication that we cannot eliminate; the
            parameter name is not available in the class' bytecode and so
            cannot be inferred automatically. Alternatively though, you could
            create a user-defined value type, using
            <literal>@Value</literal>).</para>

            <para>Similarly, any parameter may be given a short
            user-description using the <literal
            moreinfo="none">@DescribedAs</literal> annotation. The framework
            takes responsibility to make this available to the user.</para>
          </sect3>

          <sect3>
            <title>How to make a parameter optional</title>

            <para>By default, the framework assumes that when an action method
            is to be invoked, all the parameters are mandatory. You may
            over-ride this behaviour by marking up one or more of the
            paramaters with the <literal moreinfo="none">@Optional</literal>
            annotation.</para>
          </sect3>

          <sect3>
            <title>How to specify default values for parameters</title>

            <para>When an action is about to be invoked, then default values
            can be provided for any or all of its parameters.</para>

            <para>There are two different ways to specify parameters; either
            per parameter, or for all parameters. The per-parameter form is
            simpler and probably preferred; the syntax is:</para>

            <programlisting>public &lt;parameter type&gt; defaultN&lt;ActionName&gt;()</programlisting>

            <para>where N indicates the 0-based parameter number. For
            example:</para>

            <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity") 
                      int quantity) {
        ...
    }
    public Product default0PlaceOrder() {
        return productMostRecentlyOrderedBy(this.getCustomer());
    }
}</programlisting>

            <para>The syntax for specifying all the parameter default values
            in one go is:</para>

            <para><programlisting>public Object[] default&lt;ActionName&gt;([&lt;parameter type&gt; param]...)</programlisting></para>

            <para>returning an array (which must have one element per
            parameter in the action method signature) of corresponding default
            values. For example:</para>

            <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity") 
                      int quantity) {y
        ...
    }
    public Object[] defaultPlaceOrder(
                      Product product,
                      int quantity) {
        return new Object[] {productMostRecentlyOrderedBy(this.getCustomer()), 1};
    }
}</programlisting>
          </sect3>

          <sect3>
            <title>How to specify a set of choices for parameter
            values</title>

            <para>The programmer may provide a set of choices for the value of
            any or all of the parameters of an action. These will be made
            available to the user - for example as a drop-down list.</para>

            <para>As for defaults, there are two different ways to specify
            parameters; either per parameter, or for all parameters. The
            per-parameter form is simpler and probably preferred; the syntax
            is:</para>

            <programlisting>public List&lt;parameter type&gt; choicesN&lt;ActionName&gt;()</programlisting>

            <para>where N indicates the 0-based parameter number. For
            example:</para>

            <programlisting format="linespecific">public class Order {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity") 
                      int quantity) {
        ...
    }

    public List&lt;Product&gt; choices0PlaceOrder() {
        return lastFiveProductsOrderedBy(this.getCustomer());
    }
}</programlisting>

            <para>The alternative mechanism is to supply all the parameter
            choices in one go:</para>

            <para><programlisting>public Object[] choices&lt;ActionName&gt;([&lt;parameter type&gt; param]...)</programlisting></para>

            <para>returning an array, which must have one element per
            parameter in the method signature. Each element of the array
            should itself either be an array or a list, containing the set of
            values representing the choices for that parameter, or <literal
            moreinfo="none">null</literal> if there are no choices to be
            specified for that parameter.</para>

            <para>For example:</para>

            <programlisting format="linespecific">public class Order {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity") 
                      int quantity) {
        ...
    }

    public Object[] choicesPlaceOrder(
                      Product product,
                      int quantity) {
        return new Object[] {lastFiveProductsOrderedBy(this.getCustomer()).toArray(), null};
    }
}</programlisting>

            <para>(Note that if the type of the property is annotated with
            <literal moreinfo="none">@Bounded</literal>, then it is not
            necessary to specify the choices for that parameter, as the user
            will automatically be offered the full set to choose from.)</para>
          </sect3>

          <sect3>
            <title>How to specify the length or format for text-input
            parameters</title>

            <para>Use the <literal moreinfo="none">@MaxLength</literal>,
            <literal moreinfo="none">@TypicalLength</literal>, <literal
            moreinfo="none">@MultiLine</literal>, <literal
            moreinfo="none">@Mask</literal> or <literal
            moreinfo="none">@RegEx</literal> annotations.</para>
          </sect3>

          <sect3>
            <title>How to validate parameter values</title>

            <para>A <literal moreinfo="none">validate</literal> method is used
            to check that the set of arguments used by an action method is
            valid. If the arguments are invalid then the framework will not
            invoke the action. A non-null return String indicates the reason
            why the member cannot be modified/action be invoked, and the
            viewing mechanism will display this feedback to the user.</para>

            <para>The syntax is:</para>

            <para><programlisting>public String validate&lt;ActionName&gt;([&lt;parameter type&gt; param]...)</programlisting></para>

            <para>For example:</para>

            <programlisting format="linespecific">public class Customer {
    public Order placeOrder(Product p, int quantity) { ... }
    public String validatePlaceOrder(Product p, int quantity) {
        if (p.isOutOfStock()) { return "Product is out of stock"; }
        if (quantity &lt;= 0) { return "Quantity must be a positive value"; }
        return null;
    }</programlisting>
          </sect3>
        </sect2>

        <sect2>
          <title>How to specify conditions for invoking an action</title>

          <sect3>
            <title>Disabling an action based on the state of the
            object</title>

            <para>There may be circumstances in which we do not want the user
            to be able to initiate the action at all - for example because
            that action is not appropriate to the current state of the object
            on which the action resides. Such rules are enforced by means of a
            <literal moreinfo="none">disable</literal> method.</para>

            <para>The syntax is:</para>

            <para><programlisting>public String disable&lt;ActionName&gt;([&lt;parameter type&gt; param]...)</programlisting></para>

            <para>A non-null return <code>String</code> indicates the reason
            why the action may not be invoked. The framework takes
            responsibility to provide this feedback to the user. For
            example:</para>

            <programlisting format="linespecific">public class Customer {
    public Order placeOrder(Product p, int quantity) { ... }
    public String disablePlaceOrder(Product p, int quantity) { 
        return isBlackListed()?
            "Blacklisted customers cannot place orders"
            :null;
    }</programlisting>

            <para>It is also possible to permanently disable an action using
            the <literal moreinfo="none">@Disabled</literal> annotation. One
            possible reason for doing this might be during prototyping - to
            indicate to the user that an action is planned, but has not yet
            been implemented.</para>
          </sect3>

          <sect3>
            <title>Disabling an action for certain users or roles</title>

            <para>See 'Properties: Disabling a property for specific users or
            roles'. The same technique can be applied to actions. However, the
            caveats apply.</para>
          </sect3>
        </sect2>

        <sect2>
          <title>How to control the order in which actions appear on the
          menu</title>

          <para>Use the <literal moreinfo="none">@MemberOrder</literal>
          annotation.</para>
        </sect2>

        <sect2>
          <title>How to hide actions</title>

          <sect3>
            <title>Hiding an action always</title>

            <para>Use the <literal moreinfo="none">@Hidden</literal>
            annotation. (This is generally used where a <literal
            moreinfo="none">public</literal> method on an object is not
            intended to be a user action).</para>
          </sect3>

          <sect3>
            <title>Hiding an action under certain conditions</title>

            <para>A <literal moreinfo="none">hide</literal> method can be used
            to indicate that an action should be hidden under certain
            conditions. The syntax is:</para>

            <para><programlisting>public boolean hide&lt;ActionName&gt;([&lt;parameter type&gt; param]...)</programlisting></para>

            <para>A <literal moreinfo="none">true</literal> return value
            indicates that the action should not be shown. For example:</para>

            <programlisting format="linespecific">public class Order {
    
    public void applyDiscount(int percentage) { ... }
    
    public boolean hideApplyDiscount() {
        return isWholesaleOrder();
    }
}</programlisting>
          </sect3>

          <sect3>
            <title>Hiding an action for certain users or roles</title>

            <para>See 'Properties: Hiding a property for specific users or
            roles'. The same technique can be applied to actions. However, the
            caveats apply.</para>
          </sect3>
        </sect2>

        <sect2>
          <title>How to pass a message back to the user</title>

          <para>Sometimes, within an action it is necessary or desirable to
          pass a message to the user, for example to inform them of the
          results of their action ('5 payments have been issued') or that the
          action was not successful ('No Customer found with name John
          Smith'). <code>DomainObjectContainer</code> defines two methods for
          this purpose:</para>

          <para><programlisting>void informUser(String message)

void warnUser(String message)</programlisting></para>

          <para>These two methods provide different ways to send a message to
          the user, representing increasing levels of severity. How each of
          these messages is rendered visible to the user is determined by the
          framework.</para>

          <para>These two methods are also available on
          <classname>AbstractDomainObject </classname>as a shortcut.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Collections</title>

        <para>A collection is a list of references to several entity objects
        that have a common type.</para>

        <sect2>
          <title>How to add a collection to an object</title>

          <para>A collection is recognized via an accessor/mutator method pair
          (<code>get</code> and set) for any type of collection provided by
          the programming language. The syntax is:</para>

          <para><programlisting>public &lt;collection type&gt; get&lt;CollectionName&gt;()

private void set&lt;CollectionName&gt;(&lt;collection type&gt; param)</programlisting></para>

          <para>It is recommended that the collections be specified using
          generics (for example: <literal
          moreinfo="none">List&lt;Customer&gt;</literal> ). That way the
          framework will be able to display the collection based on that type
          definition. (Generics are also required by some persistence
          mechanisms). For example the viewer might display the collection as
          a table, with the columns defined by the visible properties of that
          type. The viewer will then automatically prevent the user from
          adding objects not of that type. If generics are not used then the
          type may be inferred from the <literal
          moreinfo="none">addTo</literal> / <literal
          moreinfo="none">removeFrom</literal> methods, if specified (see
          below).</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Employee { ... }

public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List &lt;Employee&gt; getEmployees() {
        return employees;
    }
    private void setEmployees(List&lt;Employee&gt; employees) { 
        this.employees = employees;
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>How to trigger other behaviour when an object is added or
          removed</title>

          <para>A collection may have a corresponding <literal
          moreinfo="none">addTo</literal> and/or <literal
          moreinfo="none">removeFrom</literal> method. This is equivalent to
          the <literal moreinfo="none">modify</literal> and <literal
          moreinfo="none">clear</literal> methods for properties. The syntax
          is:</para>

          <para><programlisting>public void addTo&lt;CollectionName&gt;(&lt;entity type&gt; param)

public void removeFrom&lt;CollectionName&gt;(&lt;entity type&gt; param)</programlisting></para>

          <para>where <literal moreinfo="none">&lt;entity type&gt;</literal>
          is the same type as the generic collection type. For example:</para>

          <programlisting format="linespecific">public class Employee { ... }

public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List &lt;Employee&gt; getEmployees() {
        return employees;
    }
    private void setEmployees(List&lt;Employee&gt; employees) { 
        this.employees = employees;
    }
    public void addToEmployees(Employee employee) {
        employees.add(employee);
    }
    public void removeFromEmployees(Employee employee) {
        employees.remove(employee);
    }

    ...
}</programlisting>

          <para>The addTo / removeFrom and modify / clear methods are
          particularly useful in setting up bidirectional relationships using
          the 'mutual registration pattern'; for a write-up of this pattern,
          see <ulink
          url="???">http://www.two-sdg.demon.co.uk/curbralan/papers/MutualRegistration.pdf</ulink>.</para>
        </sect2>

        <sect2>
          <title>How to prevent the user from modifying a collection</title>

          <para>Preventing the user from adding to or removing from a
          collection is known as 'disabling' the collection.</para>

          <sect3>
            <title>Disabling a collection permanently</title>

            <para>Use the <literal moreinfo="none">@Disabled</literal>
            annotation.</para>
          </sect3>

          <sect3>
            <title>Disabling a collection under certain conditions</title>

            <para>A <literal moreinfo="none">disable</literal> method can be
            used to disable a particular instance's collection under certain
            conditions: The syntax is:</para>

            <para><literal moreinfo="none">public String
            disable&lt;CollectionName&gt;()</literal> For example:</para>

            <programlisting format="linespecific">public class Department {
    public List&lt;Employee&gt; getEmployees() { ... }
    public void addToEmployees(Employee employee) { ... }
    public void removeFromEmployees(Employee employee) { ... }
    public void disableEmployees() {
        return isClosed()? "This department is closed" : null;
    }
}</programlisting>
          </sect3>

          <sect3>
            <title>Disabling a collection for specific users or roles</title>

            <para>See Properties: Disabling a property for specific users or
            roles'. The same technique can be applied to collections, with the
            same caveats applying.</para>
          </sect3>
        </sect2>

        <sect2>
          <title>How to validate an object to be added or removed</title>

          <para>A <literal moreinfo="none">validate</literal> method is used
          to check that an object to be added or removed from a collection is
          valid. A non-null return <code>String</code> indicates the reason
          why the object cannot be added/removed, and the viewing mechanism
          will display this to the user. The syntax is:</para>

          <para><programlisting>public String validateAddTo&lt;CollectionName&gt;(&lt;property type&gt; param) 

public String validateRemoveFrom&lt;CollectionName&gt;(&lt;property type&gt; param)</programlisting></para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt; employees) { ... }
    public String validateAddToEmployee(Employee employee) {
        return employee.isRetired()?
            "Cannot add retired employees to department"
            :null;
}</programlisting>
        </sect2>

        <sect2>
          <title>How to control the order in which collections are
          displayed</title>

          <para>Use the <literal moreinfo="none">@MemberOrder</literal>
          annotation.</para>
        </sect2>

        <sect2>
          <title>How to specify a name and/or description for a
          collection</title>

          <para>Use the <literal moreinfo="none">@Named</literal> and/or
          <literal moreinfo="none">@DescribedAs</literal> annotations.</para>
        </sect2>

        <sect2>
          <title>How to hide a collection</title>

          <para>See 'Properties: How to hide a property'. The same approaches
          work for collections.</para>
        </sect2>

        <sect2>
          <title>How to create a derived collection</title>

          <para>Collections can be derived, in the same way as properties.
          These are not persisted, but are represented as read only
          collections. For example:</para>

          <programlisting format="linespecific">public class Department {
    // Standard collection
    List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt;) { ... }
    void addToEmployees(final Employee employee) { ... }
    void removeFromEmployees(final Employee employee) { ... }

    // Derived collection
    public List&lt;Employee&gt; getTerminatedEmployees() {
        List&lt;Employee&gt; terminatedEmployees = new ArrayListt&lt;Employee&gt;();
        for(Employee e: employees) {
            if (e.isTerminated()) {
                addTo(terminatedEmployees, e);
            }
        }
        return terminatedEmployees;
    }
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>Repositories and Factories</title>

        <para>The Naked Objects application library provides a class</para>

        <para><literal
        moreinfo="none">org.nakedobjects.applib.AbstractFactoryAndRepository</literal></para>

        <para>that makes it easy to write a Repository and/or Factory to work
        entirely in memory. This is very useful during prototyping, as you can
        quickly get your system up and running without having to deal with a
        database. Refer to the JavaDoc documentation for that class for a full
        list of methods available. However, the following describes some of
        the most commonly-used methods:</para>

        <para><literal moreinfo="none">&lt;T&gt; T newTransientInstance(final
        Class&lt;T&gt; ofClass)</literal> returns a new instance of the
        specified class, that is transient (unsaved). This may subsequently be
        saved either by the user invoking the Save action (that will
        automatically be rendered on the object view) or programmatically by
        calling . . .</para>

        <para><literal moreinfo="none">void makePersistent(Object
        transientObject)</literal></para>

        <para><literal moreinfo="none">&lt;T&gt; T newPersistentInstance(final
        Class&lt;T&gt; ofClass)</literal> creates a new object already
        persisted.</para>

        <para><literal moreinfo="none">void disposeInstance(Object
        persistentObject)</literal></para>

        <para><literal moreinfo="none">&lt;T&gt; List&lt;T&gt;
        allInstances(final Class&lt;T&gt; cls, final boolean
        includeSubclasses)</literal> these may be iterated through for a
        specific match.</para>

        <para><literal moreinfo="none">&lt;T&gt; T firstMatch(final
        Class&lt;T&gt; cls, final String title, final boolean
        includeSubclasses)</literal>looks for an object with the title
        specified.</para>

        <para>There are a number of useful matching and filtering methods in
        AbstractFactoryAndRepository.</para>

        <sect2>
          <title>Finding by pattern</title>

          <remark>TODO: Complete this section to cover pattern-based
          searching, including the fact that this works for both InMemory and
          Hibernate repositories.</remark>
        </sect2>
      </sect1>

      <sect1>
        <title>@MustSatisfy specification</title>

        <para>The <literal>@MustSatisfy</literal> annotation is an alternative
        to using imperative validation, allowing validation rules to be
        captured in an (implementation of a)
        <classname>org.nakedobjects.applib.spec.Specification</classname>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class DomainObjectWithMustSatisfyAnnotations extends AbstractDomainObject {

    private String lastName;
    @MustSatisfy(SpecificationRequiresFirstLetterToBeUpperCase.class)
    public String getLastName() {
        resolve(lastName);
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        objectChanged();
    }

    public void changeLastName(
            @MustSatisfy(SpecificationRequiresFirstLetterToBeUpperCase.class)
            String lastName
            ) {
        setLastName(lastName);
    }

}</programlisting>

        <para><remark>TODO: @MustSatisfy may not work for action parameters;
        see <ulink
        url="???">http://development.nakedobjects.org/trac/ticket/669</ulink>.</remark></para>
      </sect1>

      <sect1>
        <title>Value Types</title>

        <para>In addition to the built-in value types it is also possible to
        define user-defined value types. This is typically done using the
        <classname>@Value</classname> annotation.</para>

        <para>The <literal>@Value</literal> annotation is used to provide an
        implementation of the <classname>ValueSemanticsProvider</classname>
        interface. In turn this provides objects that allow the framework to
        interact with the value, in particular for parsing (parsing strings
        into values and display values as strings), and for encoding/decoding
        (for serialization for client/server and used by some
        persistors).</para>

        <para>For more details, explore the built-in types within the applib,
        for example
        <classname>org.nakedobjects.applib.value.Money</classname>.</para>

        <programlisting format="linespecific">@Value(semanticsProviderName = "org.nakedobjects.metamodel.value.MoneyValueSemanticsProvider")
public class Money extends Magnitude {
    ...
}</programlisting>

        <para>where <classname>MoneyValueSemanticsProvider</classname> is the
        implementation of <classname>ValueSemanticsProvider</classname>
        described above.</para>

        <para>Using value types generally removes the need for using
        <literal>@MustSatisfy</literal> annotation; the rules can instead move
        down into a <methodname>validate</methodname> method on the value type
        itself.</para>

        <para><remark>TODO: need to beef up this discussion. Also, note that
        it is possible to register value types using nakedobjects.properties
        rather than the @Value annotation; this is particularly useful for
        third-party value types.</remark></para>
      </sect1>

      <sect1>
        <title>Resolve and ObjectChanged</title>

        <para>In previous versions of the framework it was necessary to call
        the inherited <methodname>resolve()</methodname> method within every
        property or collection's getter, and
        <methodname>objectChanged()</methodname> within every property's
        setter and every collection's addTo or removeFrom.</para>

        <para>These methods still exist in
        <classname>AbstractDomainObject</classname>, but no longer need to be
        called explicitly. Instead Naked Objects 4.0 uses bytecode enhancement
        (using either cglib or javassist) to automatically call these methods.
        This bytecode enhancement can be disabled in
        <filename>nakedobjects.properties</filename> file; if it is then the
        methods must be called manually as they were in Naked Objects
        3.0.</para>
      </sect1>
    </chapter>

    <chapter id="building_with_ant">
      <title>Building a Naked Objects application with Ant</title>

      <para>Once an application is written it must, like all Java programs, be
      compiled before it can be run. As you want to run your application
      within the framework there are dependencies that need to be satisfied to
      allow this. Naked Object promote two ways of doing this, using Ant and
      Maven. This section looks at how to use Ant to build a Naked Objects
      application, while the next section shows how to do the same thing with
      Maven.</para>

      <sect1>
        <title>Project organisation</title>

        <para>How you organise your project and its dependencies is a matter
        of personal preference, but for this section we will assume the
        following directory structure, where <filename class="directory"
        moreinfo="none">nakedobjects-4.0</filename> is the unzipped
        distribution and <filename class="directory"
        moreinfo="none">project</filename> is the directory containing the
        application you are working on.</para>

        <screen format="linespecific">nakedobjects-4.0/
    lib/
    resources/
    :
    :
project/
    src/
    xat/
    resources/
    config/
    build.xml
    :
    :</screen>

        <para>The source code for the domain objects is contained in the
        <filename class="directory" moreinfo="none">src</filename> directory
        and the tests are in <filename class="directory"
        moreinfo="none">xat</filename>. Resources to be made available via the
        class path (rather than loaded via the file system) should be added to
        the <filename class="directory"
        moreinfo="none">project/resources</filename> directory, while
        configuration files should be placed in <filename class="directory"
        moreinfo="none">config</filename>. The file <filename
        class="directory" moreinfo="none">build.xml</filename> should be
        copied across from the <filename class="directory"
        moreinfo="none">nakedobjects-4.0/resources</filename>
        directory.</para>
      </sect1>

      <sect1>
        <title>Compilation</title>

        <para>To build a Naked Objects application you need to have access to
        its needed libraries as well as your source code. The libraries are
        all contained in the <filename class="directory"
        moreinfo="none">lib</filename> directory within the distribution
        download. The following extract from a <filename class="directory"
        moreinfo="none">build.xml</filename> file<footnote>
            <para>The complete file can be found in the resource
            directory</para>
          </footnote> shows how you can use Ant to compile a Naked Objects
        application. The <emphasis role="strong">path</emphasis> element is
        used to link in all the Jar files that are provided by the
        distribution, while the <emphasis role="strong">compile</emphasis>
        target uses javac to compile your Java code found in the source
        directory. Make sure you change the <emphasis
        role="strong">lib.dir</emphasis> property to point to the lib
        directory within the binary download and the <emphasis
        role="strong">src.dir</emphasis> property to your source directory.
        The <emphasis role="strong">src</emphasis> directory will normally
        contain DOM classes, fixtures and application-framework integration
        code (such as repositories and services).</para>

        <programlisting format="linespecific">&lt;property name="lib.dir" value="<emphasis
            role="strong">../nakedobjects-3.0/lib/</emphasis>" /&gt;
&lt;property name="build.dir" value="./build" /&gt;
&lt;property name="classes.dir" value="./build/classes" /&gt;
&lt;property name="src.dir" value="<emphasis role="strong">./src/</emphasis>" /&gt;
&lt;property name="xat.dir" value="./xat" /&gt;
&lt;property name="compile.target" value="1.5" /&gt;
&lt;property name="source.target" value="1.5" /&gt;


&lt;fileset dir="${lib.dir}" id="libs.set"&gt;
  &lt;include name="**/*.jar" /&gt;
&lt;/fileset&gt;

&lt;path id="libs.path"&gt;
  &lt;fileset refid="libs.set" /&gt;
&lt;/path&gt;

&lt;target name="compile" description="Compile example"&gt;
  &lt;mkdir dir="${build.dir}" /&gt;
  &lt;mkdir dir="${classes.dir}" /&gt;

  &lt;javac destdir="${classes.dir}" target="${compile.target}" source="${source.target}"&gt;
      &lt;src path="${src.dir}" /&gt;
      &lt;src path="${xat.dir}" /&gt;
      &lt;classpath refid="libs.path" /&gt;
   &lt;/javac&gt;
&lt;/target&gt;</programlisting>

        <para>Running Ant with the <emphasis role="strong">compile</emphasis>
        target will compile your code, producing the following output
        indicating that the compilation was successful. The newly created
        <filename class="directory" moreinfo="none">build</filename> directory
        will contain the class files.</para>

        <screen format="linespecific">$ ant compile
Buildfile: build.xml

compile:
    [mkdir] Created dir: /home/rcm/workspace/project/build
    [javac] Compiling 17 source files to /home/rcm/workspace/project/build
    [javac] Note: Some input files use unchecked or unsafe operations.
    [javac] Note: Recompile with -Xlint:unchecked for details.

BUILD SUCCESSFUL
Total time: 2 seconds</screen>
      </sect1>

      <sect1>
        <title>Distribution</title>

        <para>A fully runnable distribution and zip file can be created using
        the build file. Ensure the <emphasis
        role="strong">resource.dir</emphasis> property points the resource
        directory in the distribution.</para>

        <programlisting format="linespecific">&lt;property name="resource.dir" value="<emphasis
            role="strong">../nakedobjects-4.0/resources</emphasis>" /&gt;

&lt;target name="dist" depends="compile" description="Collects together files for distribution"&gt;
  &lt;copy todir="${build.dir}/lib"&gt;
    &lt;fileset refid="libs.set" /&gt;
  &lt;/copy&gt;
  &lt;copy todir="${build.dir}"&gt;
    &lt;fileset dir="."&gt;
      &lt;include name="config/*" /&gt;
      &lt;include name="images/*" /&gt;
    &lt;/fileset&gt;
    &lt;fileset dir="${resource.dir}"&gt;
      &lt;include name="web/*" /&gt;
      &lt;include name="run.*"/&gt;
      &lt;include name="lcp.bat"/&gt;
    &lt;/fileset&gt;
  &lt;/copy&gt;
  &lt;chmod file="${build.dir}/nakedobjects.sh" perm="ugo+x"/&gt;

  &lt;mkdir dir="${dist.dir}" /&gt;
  &lt;zip destfile="dist/no-application.zip" &gt;
    &lt;zipfileset dir="${build.dir}" prefix="no-application" /&gt;
  &lt;/zip&gt;
&lt;/target&gt;</programlisting>

        <para>Running ant with the <emphasis role="strong">dist</emphasis>
        target will create the distribution, producing the following
        output.</para>

        <screen format="linespecific">$ ant dist
Buildfile: build.xml

compile:
dist:
     [copy] Copying 45 files to /home/rcm/workspace/project/build/lib
     [copy] Copying 7 files to /home/rcm/workspace/project/build
      [zip] Building zip: /home/rcm/workspace/project/dist/no-application.zip
BUILD SUCCESSFUL
Total time: 6 seconds</screen>

        <para>After this has completed the <filename class="directory"
        moreinfo="none">build</filename> directory will look like the
        following, and the <filename class="directory"
        moreinfo="none">dist</filename> directory will contain a zipped file
        of the same contents.</para>

        <screen format="linespecific">build/
   classes/
   config/
   images/
   lib/
   resources/
   web/
   lcp.bat
   nakedobjects.bat
   nakedobjects.sh</screen>
      </sect1>
    </chapter>

    <chapter id="building_with_maven">
      <title>Building a Naked Objects application with Maven</title>

      <section>
        <title>Creating new applications using Maven archetypes</title>

        <para>Using Maven archetype plugin we can generate a new Naked Objects
        application very quickly. These are multi-moduled projects with
        separate sections for the domain code, fixtures, web interfaces and so
        on.</para>

        <para>One option is to create the archetype from the commandline. Note
        that if you are using Eclipse and have installed the m2eclipse plugin
        then it provides a dialog to create the project from an archetype;
        this is discussed below.</para>

        <remark>TODO: update the listing below, it is out of date. The
        archetype to use is called
        'org.nakedobjects:application-archetype'.</remark>

        <screen>[rcm@localhost ~]$ <emphasis role="bold">mvn archetype:generate -DarchetypeCatalog=http://nakedobjects.org</emphasis>
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]    task-segment: [archetype:generate] (aggregator-style)
[INFO] ------------------------------------------------------------------------
[INFO] Preparing archetype:generate
[INFO] No goals needed for project - skipping
[INFO] Setting property: classpath.resource.loader.class =&gt; 'org.codehaus.plexus.velocity.ContextClassLoaderResourceLoader'.
[INFO] Setting property: velocimacro.messages.on =&gt; 'false'.
[INFO] Setting property: resource.loader =&gt; 'classpath'.
[INFO] Setting property: resource.manager.logwhenfound =&gt; 'false'.
[INFO] [archetype:generate]
[INFO] Generating project in Interactive mode
[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)
Choose archetype:
1: local -&gt; nakedobjects-application (Naked Objects Application (Archetype))
2: local -&gt; nakedobjects-icons (Naked Objects Icons (Archetype))
3: local -&gt; htmlviewer-war (Naked Objects WAR (Archetype))
4: local -&gt; hibernate-support (Hibernate Support (Archetype))
5: local -&gt; remoting-support (Naked Objects Remoting Support (Archetype))
Choose a number:  (1/2/3/4/5): <emphasis role="bold">1</emphasis></screen>

        <para>To create a project from an archetype you must specify a
        <emphasis>groupId</emphasis> and <emphasis>artifactId</emphasis>, a
        <emphasis>version</emphasis> and a <emphasis>Java
        package</emphasis>.</para>

        <para>After choosing the archetype number and pressing enter you are
        prompted for the project's details. The <emphasis>groupId</emphasis>
        is an identifier representing your company/group; ours would typically
        be "org.nakedobjects" for the domain followed by a name for the group
        of products. The <emphasis>artifactId</emphasis> identifies the
        projects that we are creating. The <emphasis>version</emphasis>
        indicates how mature the project is, and should be left as the
        default, e.g. 1.0-SNAPSHOT. Finally, the <emphasis>package</emphasis>
        is the base package name used for all Java files. After these have
        been entered you are prompted to confirm by entering Y, as shown
        below.</para>

        <para>Be wary of using invalid names. The <emphasis>groupId</emphasis>
        should be alphanumeric with dots to separate the words. The
        <emphasis>artifactId</emphasis> should also be alphanumeric, with '-'
        (hyphens) to separate the words. The <emphasis>package</emphasis> name
        should be a valid Java package name, i.e. should have no spaces or
        dashes. Maven does little to check these things.</para>

        <screen>Define value for groupId: : <emphasis role="bold">org.example</emphasis>
Define value for artifactId: : <emphasis role="bold">expenses</emphasis>
Define value for version:  1.0-SNAPSHOT: : 
Define value for package: : <emphasis role="bold">org.example.expenses</emphasis>
Confirm properties configuration:
groupId: org.example
artifactId: expenses
version: 1.0-SNAPSHOT
package: org.example.expenses
 Y: : <emphasis role="bold">y</emphasis>
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 minute 13 seconds
[INFO] Finished at: Thu Oct 02 20:42:50 BST 2008
[INFO] Final Memory: 13M/247M
[INFO] ------------------------------------------------------------------------
</screen>

        <para>This will create a new directory with the name of the
        <emphasis>artifactId</emphasis>. So in this example this is
        <filename>expenses</filename> as shown below.<screen>expenses
|-- pom.xml
|-- dom
|   |-- pom.xml
|   `-- src
|-- commandline
|   |-- config
|   |-- ide
|   |-- pom.xml
|   `-- src
|-- fixture
|   |-- pom.xml
|   `-- src
|-- service
|   |-- pom.xml
|   `-- src
`-- webapp
    |-- pom.xml
    `-- src</screen></para>
      </section>

      <section>
        <title>Building a Naked Objects application</title>

        <para>Once an archetype is created it can be built using Maven and
        run. Build using the <emphasis>install</emphasis> goal as shown
        here.</para>

        <screen>[rcm@localhost expenses]$ <emphasis role="bold">mvn clean install</emphasis>
[INFO] Scanning for projects...
[INFO] Reactor build order: 
[INFO]   Naked Object Application
[INFO]   Domain Model
[INFO]   Services
[INFO]   Fixtures
[INFO]   Exploration
[INFO] ------------------------------------------------------------------------
[INFO] Building Naked Object Application
[INFO]    task-segment: [clean, install]
[INFO] ------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] [site:attach-descriptor]
[INFO] [install:install]
[INFO] Installing /home/rcm/tmp/bearingpoint/expenses/pom.xml to /home/rcm/.m2/repository/org/example/expenses/1.0-SNAPSHOT/expenses-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] Building Domain Model
[INFO]    task-segment: [clean, install]
[INFO] ------------------------------------------------------------------------
[INFO] [clean:clean]
[INFO] Deleting directory /home/rcm/tmp/bearingpoint/expenses/dom/target
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 7 source files to /home/rcm/tmp/bearingpoint/expenses/dom/target/classes
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
:
:
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] No sources to compile
[INFO] [surefire:test]
[INFO] No tests to run.
[INFO] [jar:jar]
[INFO] Building jar: /home/rcm/tmp/bearingpoint/expenses/exploration/target/expenses.jar
[INFO] [assembly:attached {execution: default}]
[INFO] Reading assembly descriptor: src/main/assembly/descriptor.xml
[INFO] Processing DependencySet (output=lib)
[INFO] Copying files to /home/rcm/tmp/bearingpoint/expenses/exploration/target/expenses-exploration-1.0-SNAPSHOT-prototype.dir
[WARNING] Assembly file: /home/rcm/tmp/bearingpoint/expenses/exploration/target/expenses-exploration-1.0-SNAPSHOT-prototype.dir is not a regular file (it may be a directory). It cannot be attached to the project build for installation or deployment.
[INFO] [install:install]
[INFO] Installing /home/rcm/tmp/bearingpoint/expenses/exploration/target/expenses.jar to /home/rcm/.m2/repository/org/example/expenses-exploration/1.0-SNAPSHOT/expenses-exploration-1.0-SNAPSHOT.jar
[INFO] 
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ------------------------------------------------------------------------
[INFO] Naked Object Application .............................. SUCCESS [6.087s]
[INFO] Domain Model .......................................... SUCCESS [8.711s]
[INFO] Services .............................................. SUCCESS [2.432s]
[INFO] Fixtures .............................................. SUCCESS [2.283s]
[INFO] Commandline ........................................... SUCCESS [10.774s]
[INFO] ------------------------------------------------------------------------
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 31 seconds
[INFO] Finished at: Tue Mar 03 11:59:50 GMT 2009
[INFO] Final Memory: 40M/495M
[INFO] ------------------------------------------------------------------------
[rcm@localhost expenses]$ </screen>

        <para>Once the project is built the results can be found in the
        <filename>exploration/target</filename> directory, which contains both
        a zipped distribution (in this example
        <filename>expenses-exploration-1.0-SNAPSHOT-prototype.zip</filename>)
        and an expanded distribution (again for this example,
        <filename>expenses-exploration-1.0-SNAPSHOT</filename>). Using the
        contained script files the application can be run from the command
        line.<screen>exploration
|-- config
|-- ide
|-- pom.xml
|-- src
`-- target
    |-- archive-tmp
    |-- classes
    |-- expenses-exploration-1.0-SNAPSHOT-prototype.dir
    |   `-- expenses-exploration-1.0-SNAPSHOT
    |       |-- config
    |       |-- images
    |       |-- expenses.jar
    |       |-- nakedobjects.bat
    |       |-- nakedobjects.sh
    |       |-- lib
    |-- expenses-exploration-1.0-SNAPSHOT-prototype.zip
    |-- expenses.jar
    `-- maven-archiver</screen></para>
      </section>

      <section>
        <title>Using Eclipse for development</title>

        <para>There are two approaches for using Eclipse in
        development.</para>

        <para>The recommended approach is to use the Eclipse's Maven plug-in,
        m2eclipse, obtainable from <ulink
        url="???">http://m2eclipse.sonatype.org/</ulink>. This then allows the
        Maven projects to be imported directly using File &gt; Import &gt;
        Maven Projects.</para>

        <para></para>

        <remark>TODO: would be good to have some screenshots of using
        m2eclipse to import projects here.</remark>

        <para></para>

        <para>In fact, you can use m2eclipse to create the project from the
        archetype in a single go:</para>

        <para></para>

        <para><remark>TODO: would be good to have a screenshot of using
        m2eclipse to generate project using archetype here.</remark></para>

        <para></para>

        <para>Alternatively you can use Maven's Eclipse plug-in to generate
        .project and .classpath files. These can then be imported into Eclipse
        using File &gt; Import &gt; Existing Projects. The remainder of this
        section discusses this alternative approach; to reiterate the
        m2eclipse approach is more straightforward and generally
        preferred.</para>

        <screen>[rcm@localhost ~]$ <emphasis role="bold">cd expenses/</emphasis>
[rcm@localhost expenses]$ <emphasis role="bold">mvn eclipse:eclipse</emphasis>
[INFO] Scanning for projects...
[INFO] Reactor build order: 
[INFO]   Naked Object Application
[INFO]   Domain Model
[INFO]   Fixtures
[INFO]   Services
[INFO]   Exploration
[INFO]   Hibernate Object Store
[INFO]   Web App
[INFO]   Client Distribution
[INFO]   Server Distribution
[INFO] Searching repository for plugin with prefix: 'eclipse'.
[INFO] ------------------------------------------------------------------------
[INFO] Building Naked Object Application
[INFO]    task-segment: [eclipse:eclipse]
[INFO] ------------------------------------------------------------------------
[INFO] Preparing eclipse:eclipse
:
:
:
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 minute 22 seconds
[INFO] Finished at: Thu Oct 02 20:44:41 BST 2008
[INFO] Final Memory: 32M/247M
[INFO] ------------------------------------------------------------------------</screen>

        <para>This downloads all the required libraries and creates
        <filename>.project</filename> and <filename>.classpath</filename>
        files for Eclipse to use. After this is complete we can start up
        Eclipse and import the projects.</para>

        <screen>[rcm@localhost expenses]$ <emphasis role="bold">eclipse -data .</emphasis></screen>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/eclipse-platform.png" width="40%" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>The workspace starts off empty as this is a new project. First
        we need to import the modules using the
        <guimenu>File/Import...</guimenu> menu. On the first page of this
        dialog select the <emphasis role="strong">Existing Project into
        Workspace</emphasis> option.</para>

        <screenshot>
          <screeninfo></screeninfo>

          <mediaobject>
            <imageobject>
              <imagedata fileref="???" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/eclipse-Import.png" width="40%" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>After selecting the same directory that we are running in, then
        you select all the modules in the list as Eclipse projects to
        import.</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/eclipse-Import2.png" width="40%" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>All the libraries are referenced using a the variable M2_REPO,
        so this needs to be set up in the Classpath variables in the main
        preferences. In the <emphasis>Classpath Variable</emphasis> tab press
        the <guibutton>New...</guibutton> button.</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/eclipse-Preferences%20.png"
                         width="40%" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>Enter the name <emphasis>M2_REPO</emphasis> and find the path to
        <filename>.m2/repository</filename>.</para>

        <para>Now to run the application select <guimenu>Run/Run
        Configuration...</guimenu> on the commandline project and browse for
        the class
        <classname>org.nakedobjects.runtime.NakedObjects</classname>. With
        that selected press the <guibutton>Run</guibutton> button.</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/eclipse-Run%20Configurations%20.png"
                         width="40%" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>After a short while the login dialog should appear. Logon with a
        valid user name and password, like <emphasis>sven</emphasis> and
        <emphasis>pass</emphasis>.</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/example-Login.png" width="12%" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para>When the application has finished starting up you should the
        services on the DnD user interface.</para>

        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/example-screen.png" width="40%" />
            </imageobject>
          </mediaobject>
        </screenshot>

        <para></para>
      </section>
    </chapter>

    <chapter>
      <title>Running a Naked Objects application as a prototype</title>

      <para>A Naked Objects application is commonly developed in two stages.
      First it is developed as standalone prototype, running on a single
      machine, with no security, and with all the objects in memory. Then it
      is converted into a deployable application i.e. running on a server with
      multiple clients, with a persistence layer (most commonly in the form of
      the Hibernate Object Store) and with full authentication and
      authorization. (Note that these two phases do not have to be sequential,
      you might prefer to develop your system feature-by-feature right through
      to a deployable version.) In this section we show you how to run Naked
      Objects as prototype; in the next section we show you how to deploy the
      same domain object model as the real application.</para>

      <para>Running a Naked Objects application generally requires some
      configuration files and images. Resources are typically loaded from the
      working directory, while specific resources can be loaded from the class
      path. Assuming that we will be running from the development directory
      the following structure is typical of a Naked Objects
      application.</para>

      <screen format="linespecific">project/
    src/
    xat/
    config/
        nakedobjects.properties
        passwords
    images/
    build.xml
    :</screen>

      <sect1>
        <title>Configuration</title>

        <para>Naked Objects loads in one or more properties files during
        startup. The properties files must contain at least a list of services
        that the application uses and commonly there is also a list of
        fixtures that are to be run at startup. In addition to the core
        properties there may be also other properties that are used by other
        components. The file <filename class="directory"
        moreinfo="none">nakedobjects.properties</filename> is always loaded
        up, while other properties files relating to specific components are
        only loaded up if the component they relate to is to be is used. For
        example when using the DND viewer the system will also load in the
        file <filename class="directory"
        moreinfo="none">viewer_dnd.properties</filename>, and when using the
        hibernate object store the file <filename class="directory"
        moreinfo="none">persistor_hibernate.properties</filename> is loaded.
        While <filename class="directory"
        moreinfo="none">nakedobjects.properies</filename> must exist for the
        framework to start up properly, all other properties files are
        optional.</para>

        <para>The example <filename class="directory"
        moreinfo="none">nakedobjects.properties</filename> file below shows a
        number of service classes being listed along with a generic repository
        for accessing Location objects. The prefix is prepended to each class
        name before loading. The second set of properties lists the fixture
        classes to load and instantiate.</para>

        <programlisting format="linespecific">nakedobjects.services.prefix=org.nakedobjects.example.ecs
nakedobjects.services=repository#Location,resources.CustomerRepository, \
  CustomerFactory, BookingFactory, resources.PaymentMethodFactory, \
  resources.PhoneNumberFactory, LocationFactory

nakedobjects.fixtures.prefix=org.nakedobjects.example.ecs.fixtures
nakedobjects.fixtures=CitiesFixture, BookingsFixture, ContextFixture</programlisting>
      </sect1>

      <sect1>
        <title>Authentication</title>

        <para>By default the authentication mechanism is a username/password
        challenge with the details stored in a password file called <filename
        class="directory" moreinfo="none">passwords</filename>. This file is a
        simple list of user names and their corresponding passwords separated
        by a colon. The file below shows two users with badly chosen
        passwords.</para>

        <programlisting format="linespecific">jbrown:pass
tsmith:pass</programlisting>
      </sect1>

      <sect1>
        <title>Images</title>

        <para>The drag and drop and web interfaces both display icons as part
        of the views for each object. Images for these icons, and for other
        uses, are sought in the <filename class="directory"
        moreinfo="none">images</filename> directory. The web interface
        currently only works with GIF images, while the DnD interface will
        work with GIF, PNG and JPEG images. The following shows images for the
        main objects in the ECS example.</para>

        <screen format="linespecific">images
    Booking.gif
    City.gif
    CreditCard.gif
    Customer.gif
    Location.gif
    Telephone.gif
</screen>
      </sect1>

      <sect1>
        <title>Bootloader</title>

        <para>Running a naked objects application is done via the Naked
        Objects boot loader, which is the class
        <classname>NakedObjects</classname>. Without any arguments Naked
        Objects will be started in prototype mode with the Drag and Drop
        viewer. The example below shows the Ant target (from the build
        template file) that will start up Naked Objects in exploration mode.
        The classpath is simply a list of all the library jars (as compiled by
        the <emphasis role="strong">path</emphasis> element) and the classes
        compiled by the <emphasis role="strong">compile</emphasis> target show
        previously.</para>

        <programlisting format="linespecific">&lt;property name="bootclass" value="org.nakedobjects.runtime.NakedObjects"/&gt;

&lt;path id="libs.external"&gt;
  &lt;fileset dir="${lib.dir}"&gt;
      &lt;include name="**/*.jar" /&gt;
  &lt;/fileset&gt;
&lt;/path&gt;

&lt;target name="exploration-dnd" depends="compile" 
  description="Run exploration class using drag-and-drop graphical viewer"&gt;

    &lt;java fork="yes" classname="${bootclass}"&gt;
      &lt;classpath path="${classes.dir}" /&gt;
      &lt;classpath refid="libs.external" /&gt;
      &lt;arg line="<emphasis role="strong">--type exploration --viewer dnd</emphasis>"/&gt;
    &lt;/java&gt;
&lt;/target&gt;

</programlisting>

        <para>Run</para>

        <screen format="linespecific">$ ant exploration-dnd
Buildfile: build.xml</screen>

        <para>By changing the command line parameters you can change the way
        that Naked Objects starts up. This can include using different:
        viewers, such as web browser, command line and drag and drop;
        persistors, such as Hibernate, XML, and in-memory; and modes, such as
        standalone, client and server. Details on all the options are listed
        in the reference section.</para>

        <para></para>

        <para><remark>TODO: need to discuss the alternative
        org.nakedobjects.webserver.WebServer bootloader that can be used to
        run the webapp defined by the webapp project's web.xml
        descriptor.</remark></para>
      </sect1>
    </chapter>

    <chapter>
      <title>a Naked Objects application for enterprise use</title>

      <para>Assuming that you have developed your domain model and tested it
      as a standalone prototype (previous section), this section describes the
      process of deploying the domain object model as an enterprise
      application.</para>

      <sect1>
        <title>Running Client-Server over Sockets</title>

        <sect2>
          <title>Running Naked Objects as a socket server</title>

          <screen format="linespecific">$ nakedobjects.sh --type server --viewer xstream-sockets --persistor xml</screen>

          <para>This command runs Naked Objects as a socket server. The
          <methodname>viewer</methodname> command line option specifies that
          the server will listen for requests using basic TCP/IP plain sockets
          with the XStream marshalling mechanism. The
          <methodname>persistor</methodname> command line option indicates to
          use XML object store as the persistence mechanism.</para>
        </sect2>

        <sect2>
          <title>Running Naked Objects as a socket client</title>

          <screen format="linespecific">$ nakedobjects.sh --type client --viewer dnd --connector xstream-sockets </screen>

          <para>This commands starts up Naked Objects as a client, using the
          DND viewer. The <methodname>connector</methodname> command line
          option indicates to use the XStream marshalling mechanism over basic
          TCP/IP sockets. As we are now running a multi-user system more than
          one client can be started up.</para>

          <para>To allow the client to connect to a remote server the
          <methodname>address</methodname> property needs to be specified. For
          simplicity this can be added the <filename class="directory"
          moreinfo="none">nakedobjects.properties</filename> file, but it may
          alternatively be placed in a separate file called <filename
          class="directory"
          moreinfo="none">transport_sockets.properties</filename>.</para>

          <programlisting format="linespecific">nakedobjects.transport.sockets.host = server.mycompanyname.com</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>Running Client-Server over HTTP</title>

        <sect2>
          <title>Running Naked Objects as a HTTP server</title>

          <screen format="linespecific">$ nakedobjects.sh --type server --viewer encoding-http --persistor xml</screen>

          <para>This command runs Naked Objects as a server. The
          <methodname>viewer</methodname> command line parameter specifies
          that the server will listen using http using the encoding
          marshalling mechanism. The <methodname>persistor</methodname>
          property XML object store as the persistence mechanism - a very
          simple persistence mechanism useful for initial prototyping. (In
          fact, the XML object store is the default persistence mechanism, so
          this property may be omitted from the command).</para>

          <para>Alternatively the remoting servlet
          <classname>EncodingOverHttpRemotingServlet</classname> can be added
          to the <filename>web.xml</filename> in the webapp project and the
          Naked Objects run as a web app, see below.</para>
        </sect2>

        <sect2>
          <title>Running Naked Objects as socket client</title>

          <screen format="linespecific">$ nakedobjects.sh --type client --viewer dnd --connector encoding-http </screen>

          <para>This commands starts up Naked Objects as a client, using the
          DND viewer. The <methodname>connector</methodname> command line
          option indicates to use submit requests using http and with the
          encoding marshalling mechanism. Again, as we are now running a
          multi-user system more than one client can be started up.</para>

          <para>To allow the client to connect to a remote server the
          <methodname>address</methodname> property needs to be specified. For
          simplicity this can be added the <filename class="directory"
          moreinfo="none">nakedobjects.properties</filename> file, but it may
          alternatively be placed in a separate file called <filename
          class="directory"
          moreinfo="none">transport_http.properties</filename>.</para>

          <programlisting format="linespecific">nakedobjects.transport.http.url = http://server.mycompanyname.com:8080/remoting.svc</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>Running as a WebApp</title>

        <para>Naked Objects provides three different ways to run as a
        webapp:</para>

        <sect2>
          <title>Using nakedobjects.sh</title>

          <screen format="linespecific">$ nakedobjects.sh --type server --viewer html --persistor xml
2007-08-09 12:37:13.671::INFO:  Logging to STDERR via org.mortbay.log.StdErrLog
2007-08-09 12:37:13.801::INFO:  jetty-6.0.2
2007-08-09 12:37:13.954::INFO:  Started SocketConnector @ 0.0.0.0:8080
</screen>

          <para>This command runs the Naked Objects with the HTML viewer,
          allowing multiple clients to access it via a browser. As for the
          standalone version the users need to access the URL
          http://<emphasis>server/logon.app</emphasis> to access the log on
          page.</para>
        </sect2>

        <sect2>
          <title>Using WebServer bootstrap</title>

          <para>The next mechanism uses the
          <classname>org.nakedobjects.webserver.WebServer</classname>
          bootstrap to run Naked Objects. This loads up whatever is in the
          webapp project's <filename>web.xml</filename> file.</para>

          <para><remark>TODO: we don't have a webserver.sh script to show this
          in action; we probably should.</remark></para>

          <para>Ordinarily the web.xml will be configured to run the same HTML
          viewer, so the end result will be the same. However, if necessary
          the remoting servlet can also be configured</para>
        </sect2>

        <sect2>
          <title>Deploying as a WAR</title>

          <para>The final mechanism is to use Maven to package up the webapp
          project as a WAR file, packaging up whatever is in the web.xml file.
          As above, ordinarily the web.xml will be configured to run the same
          HTML viewer, so the end result will be the same. However, if
          necessary the remoting servlet can also be configured</para>

          <para>Packaging up is done using:</para>

          <screen format="linespecific">$ cd webapp
$ mvn clean package</screen>

          <para>This should result in a WAR file in
          <filename>target</filename> directory. This can be deployed to an
          existing servlet containerd</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Setting up perspectives</title>

        <para>Perspectives allow the set of services available to a user (eg
        as icons in the DnD viewer) to be customized for that user. Since
        these services represent the "start points" for the user to interact
        with the domain model, they in a sense define an application on a
        per-user basis.</para>

        <para>The perspectives are stored in user-profiles, which are a
        persistence mechanism independent of the object store. (The intent is
        for user profiles to store additional information for use by viewers,
        for example allowing a user to reskin an application or change colors
        or fonts. As of NOF 4.0 the functionality provided is still limited,
        however).</para>

        <para>The key here is that if a user logs in and no perspective exists
        for that user then one will be created for them. The new perspective
        will be a copy of the 'template' perspective, or, if none was defined,
        a perspective containing all the known services. To create a template
        perspective add a perspective fixture that calls
        <methodname>saveAsDefault()</methodname>, rather than
        <methodname>saveForUser()</methodname> for a named user, as shown
        below.</para>

        <programlisting>public class PerspectivesFixture extends UserProfileFixture {
    @Override
    protected void installProfiles() {
        Profile profile = newUserProfile();
        Perspective perspective = profile.newPerspective("ECS");
        perspective.addToServices(LocationFactory.class);
        perspective.addToServices(CustomerRepository.class);
        perspective.addToServices(PaymentMethodFactory.class);
        
        saveAsDefault(profile);
    }
}
</programlisting>

        <para>With that set up, when a new user now logs in they will see
        three service icons on the screen for locations, customers and payment
        methods. On the drag and drop user interface the user can add and
        remove services from their perspective. To remove a service icon
        right-click on the grey border and select the close option. To add a
        service select the Services... option from the application menu
        (accessed by right-clicking on the application background) and drag
        the required service onto the desktop. Unfortunately there is no
        similar mechanism available on the HTML user interface so you will
        need to modify the created perspectives via the DND UI.</para>
      </sect1>

      <sect1>
        <title>Adding authentication and authorization</title>

        <para><remark>TODO: this material seems to repeat a lot of what is in
        <xref linkend="managing_security" />; should be merged and
        simplified.</remark></para>

        <para></para>

        <para>Starting Naked Objects requires a user name and password . (The
        exception is when running in exploration mode, which uses default
        values). The simplest way to specify the list of user names and
        passwords is in a passwords file.</para>

        <sect2>
          <title>Authentication using a passwords file</title>

          <para>Create a file called <filename class="directory"
          moreinfo="none">password</filename>s, and place into the <filename
          class="directory" moreinfo="none">config</filename> directory as the
          following example shows.</para>

          <screen format="linespecific">config/
   passwords
</screen>

          <para>The following example shows how user names (sven and dick) and
          corresponding passwords (passwd1 and passwd2) should be specified in
          the password file.</para>

          <programlisting format="linespecific">sven:passwd1
dick:passwd2</programlisting>
        </sect2>

        <sect2>
          <title>Authorization using Allow and/or Disallow files</title>

          <para>Authorization allows access to actions and properties to be
          controlled by configuration. Authorization is entirely optional and
          is disabled by default - in which case every user is given access to
          all actions and properties. A prerequisite for authorization is for
          users to have roles. These should be added to the password file as
          follows.</para>

          <programlisting format="linespecific">sven:passwd1:ordinary_user
dick:passwd2:special_user|admin</programlisting>

          <para>Sven has the role 'ordinary_user', dick has the two roles
          'special_user' and 'admin'.</para>

          <para>Naked Objects needs to be told which actions and properties
          are authorised for which roles. The simplest way to do this is in a
          file i.e. <filename class="directory"
          moreinfo="none">allow</filename> in the config directory.</para>

          <screen format="linespecific">config/
   <emphasis role="strong">password</emphasis>
      <emphasis role="strong">allow</emphasis>
   </screen>

          <para>Each entry in the <filename class="directory"
          moreinfo="none">allow</filename> file specifies either a class, or a
          particular action or property within a class, together with the
          roles that are allowed to access it. E.g.</para>

          <screen format="linespecific">example.dom.PhoneNumber#Number:ordinary_user|special_user
example.dom.Contact#Phones:ordinary_user|special_user
example.dom.Contact#FullName:ordinary_user|special_user
org.nakedobjects.nof.core.service.SimpleRepository#FindByTitle(java.lang.String):ordinary_user|special_user
example.dom.PhoneNumber#Type:ordinary_user|special_user
example.dom.Contact#KnownAs:ordinary_user|special_user
org.nakedobjects.nof.core.service.SimpleRepository#NewPersistentInstance():ordinary_user|special_user
example.dom.Contact#CreatePhone():special_user
org.nakedobjects.nof.core.service.SimpleRepository#NewTransientInstance():ordinary_user|special_user
org.nakedobjects.nof.core.service.SimpleRepository#AllInstances():ordinary_user|special_user
</screen>

          <para>The above file allows 'example.dom.Contact#CreatePhone()' only
          for users with role 'special_user' all other actions and properties
          are allowed for roles 'ordinary_user' and 'special_user'. A
          different, terser implementation of this would be to use separate
          <filename class="directory" moreinfo="none">allow</filename> and
          <filename class="directory" moreinfo="none">disallow</filename>
          files, or example, the <filename class="directory"
          moreinfo="none">allow</filename> file:</para>

          <screen format="linespecific">example.dom.PhoneNumber:ordinary_user|special_user
example.dom.Contact:ordinary_user|special_user
org.nakedobjects.nof.core.service.SimpleRepository:ordinary_user|special_user
</screen>

          <para>and the <filename class="directory"
          moreinfo="none">disallow</filename> file:</para>

          <screen format="linespecific">example.dom.Contact#CreatePhone():ordinary_user</screen>

          <para>For more details, see the section on Managing Security.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Configuration</title>

        <para>No configuration is necessary for the simplest (file-based)
        authentication mechanism. For authorization the reflector needs to be
        decorated to look up the permissions every time the framework needs
        information about the visibility of fields and menus. To include the
        decorator add the following to a properties file.</para>

        <programlisting format="linespecific">nakedobjects.reflector.facet-decorators=file-security</programlisting>

        <para>If a <filename class="directory"
        moreinfo="none">disallow</filename> file is to be used, this needs to
        be specified explicitly (the <filename class="directory"
        moreinfo="none">allow</filename> file will be picked up
        automatically):</para>

        <programlisting format="linespecific">nakedobjects.security.blacklist.file=config/disallow</programlisting>
      </sect1>

      <sect1>
        <title>Adding support for internationalisation</title>

        <para>All the text that appears to the user comes from the domain
        object model. Any literal text used within the code may be
        externalised, and localised using the standard Java mechanism of
        resource bundles. However as all field and menu names are derived from
        the method names the framework provides a mechanism to adapt these
        names using resource bundles as well.</para>

        <sect2>
          <title>Localisation files</title>

          <para>Create a file for each required language, e.g., <filename
          class="directory" moreinfo="none">i18n_en_GB.properties</filename>
          for English in Great Britain, and place them into the project such
          that they will be included in the class path. For the project
          structures we have already seen the files could be added to the
          <filename class="directory" moreinfo="none">resources</filename>
          directory, as the following example shows.</para>

          <screen format="linespecific">resources/
   <emphasis role="strong">i18n_en_GB.properties
   i18n_de_DE.properties
   i18n_fr_FR.properties</emphasis>
   </screen>

          <para>The following example is part of one of those translation file
          and shows how property and action names and descriptions may be
          specified.</para>

          <programlisting format="linespecific">example.dom.Contact.property.Phone.name=Téléphone
example.dom.Contact.action.NewPhone.name=Nouveau téléphone
example.dom.Contact.property.FullName.description=Le nom complet du client</programlisting>

          <para>For more details on defining localisation files, <xref
          linkend="i18n-files" />.</para>
        </sect2>

        <sect2>
          <title>Configuration</title>

          <para>The reflector needs to be decorated with a facet decorator to
          look up the translated names every time the framework needs
          information about the fields and menus. To include the decorator add
          the following to a properties file.</para>

          <programlisting format="linespecific">nakedobjects.reflector.facet-decorators=resource-i18n</programlisting>

          <para>If the application is being accessed via the web (html)
          viewer, then the server will need to perform the localisation, so
          the above property should be included in one of
          nakedobjects.properties read by the server; if the application is
          being accessed by a client (e.g. the DND viewer) then the
          localisation will be performed within the client, and the property
          should be specified in one of the properties files read by the
          client e.g. <filename class="directory"
          moreinfo="none">facet-decorator_i18n.properties</filename>.</para>

          <para>The locale will be picked up automatically from the machine on
          which the code is executing. You may override this by specifying the
          <link linkend="locale">locale</link> in a properties file.</para>
        </sect2>
      </sect1>
    </chapter>

    <chapter id="managing_security">
      <title>Managing security</title>

      <para>Naked Objects supports authentication&nbsp; and role-based
      authorization. Within the framework the user is represented by a
      <classname>Session</classname> object. From the session object you can
      get the name of the user and their roles.</para>

      <para>The session is used within the distribution mechanism and the
      security manager. The security manager uses the session to determine if
      a user can access or manipulate an object member. The distribution
      mechanism passes the session to the server so the server knows which
      user is accessing it.</para>

      <sect1>
        <title>Authentication</title>

        <para>An <classname>Authoriser</classname> processes an
        <classname>AuthorizationRequest</classname> and if granted generates a
        <classname>Session</classname> object to represent the user.</para>

        <sect2>
          <title>Authentication through a passwords file</title>

          <para>To explicitly use file-based authentication set the following
          property. (Note, however, that if this property is absent, the
          framework will anyway assume file-based authentication as the
          default).</para>

          <programlisting format="linespecific">nakedobjects.authentication=file</programlisting>

          <para>The location and name of the passwords file may be specified
          explicitly - if not it defaults to the <filename class="directory"
          moreinfo="none">passwords</filename> file, assumed to be in the
          <filename class="directory" moreinfo="none">config</filename>
          directory (or under WEB-INF if running as a web application).</para>

          <programlisting format="linespecific">nakedobjects.authentication.file.location= passwords  </programlisting>

          <para>The <filename class="directory"
          moreinfo="none">passwords</filename> file contains users, passwords
          and any roles, as follows.</para>

          <programlisting format="linespecific">&lt;user&gt;:&lt;password&gt;:&lt;role&gt;|&lt;role&gt;|...</programlisting>

          <para>For example, user 'sven', with password 'pass' and roles
          'role1' and 'role2' would be</para>

          <programlisting format="linespecific">sven:pass:role1|role2 </programlisting>
        </sect2>

        <sect2>
          <title>Authentication through an LDAP server</title>

          <para>To authenticate through LDAP set</para>

          <programlisting format="linespecific">nakedobjects.authentication=ldap</programlisting>

          <para>LDAP needs a URL for the server and a 'dn' of the root of the
          users on the server. For example,</para>

          <programlisting format="linespecific">nakedobjects.authentication.ldap.dn= dc=nakedobjects, dc=org </programlisting>

          <programlisting format="linespecific">nakedobjects.authentication.ldap.server=ldap://localhost:10389</programlisting>

          <para>The logon password check will be on uid='username', &lt;dn&gt;
          - For example, attempting to logon with user 'sven' with the above
          settings will check against the server on localhost, port = 10389,
          uid=sven, dc=nakedobjects, dc=org, using the password in the
          standard <literal moreinfo="none">userpassword</literal> attribute
          in that entry. Once logged in, roles will be picked up from
          cn='rolename' where objectclass =organizationalRole in child entries
          of the user entry.</para>
        </sect2>

        <sect2>
          <title>Authentication through a database</title>

          <para>To authenticate through a database set</para>

          <programlisting format="linespecific">nakedobjects.authentication=database</programlisting>

          <para>Database authentication is dependent upon Hibernate.
          Authentication tables should exist in the database configured in the
          <filename class="directory"
          moreinfo="none">hibernate.cfg.xml</filename> settings. By default
          this will check against a set of user and role database tables
          described as follows.</para>

          <programlisting format="linespecific">CREATE TABLE user (id INTEGER  NOT NULL , username VARCHAR(255) NOT NULL,password VARCHAR(255) NOT NULL, PRIMARY KEY (id));
CREATE TABLE role (id INTEGER  NOT NULL , rolename VARCHAR(255) NOT NULL, PRIMARY KEY (id)) ;
CREATE TABLE user_role (id INTEGER  NOT NULL , user INTEGER  NOT NULL,role INTEGER  NOT NULL, PRIMARY KEY (id));</programlisting>

          <para>The password should be encrypted using the 'MD5' algorithm.
          (Example code from <ulink
          url="http://developers.sun.com/learning/javaoneonline/2007/pdf/TS-6676.pdf">sun</ulink>
          ).</para>

          <programlisting format="linespecific">private String generateHash(String key) {
   MessageDigest md = MessageDigest.getInstance("MD5");
   md.reset();
   md.update(key.getBytes());
   byte[] bytes = md.digest();
   // buffer to write the md5 hash to
   StringBuffer buff = new StringBuffer();
   for (int l=0;l&lt; bytes.length;l++) {
      String hx = Integer.toHexString(0xFF &amp; bytes[l]);
      // make sure the hex string is correct if 1 character
      if(hx.length() == 1) buff.append("0");
      buff.append(hx);
   }
return buff.toString();}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title id="authorization">Authorization</title>

        <para>As with authentication, authorization may be executed via a
        file, LDAP, or database. If no authorization mechanism is specified,
        all domain calls, methods and properties will be available to all
        users.</para>

        <sect2>
          <title>Authorization through 'allow' and 'disallow' files</title>

          <para>To enable authorization by file including the facet and
          specifying the authorization implementation in the settings</para>

          <programlisting format="linespecific">nakedobjects.reflector.facets.include=\
    org.nakedobjects.runtime.authorization.standard.AuthorizationFacetFactoryImpl
nakedobjects.authorization=file</programlisting>

          <para>With file authorization the current user's role will be
          authorised against a white and (optionally) a black list for each
          method possibly available to them. The files are identified by
          properties, e.g.</para>

          <programlisting format="linespecific">nakedobjects.authorization.file.whitelist=allow
nakedobjects.authorization.file.blacklist=disallow  </programlisting>

          <para>The white list file is mandatory, if there is no property it
          defaults to 'allow' (picked up from the config directory or from
          WEB-INF if running as a webapp). The black list file is optional.
          The presence of the property indicates it is being used. If the
          white list file default is being used then 'disallow' is suggested
          as a setting for the black list.</para>

          <para>Each file contains a signature to match against and a list of
          roles. A match in the white list file permits the method and match
          in the black list forbids it. The black list overrides the white
          list. Matching occurs at three levels class, method (or property)
          and parameters. Property matches are to the bean property name e.g.
          'phone' for getPhone and setPhone.</para>

          <para>Formatted as follows:</para>

          <para>If only class is to be matched: &lt;fully qualified class&gt;
          :role1|role2|..</para>

          <para>Class and method: &lt;fully qualified
          class&gt;#&lt;method&gt;:role1|role2|..</para>

          <para>Class and property: &lt;fully qualified
          class&gt;#&lt;property&gt;:role1|role2|..</para>

          <para>Parameters where method takes no parameters: &lt;fully
          qualified class&gt;#&lt;method&gt;():role1|role2|...</para>

          <para>Parameters where method takes one parameter: &lt;fully
          qualified class&gt;#&lt;method&gt;(fully qualified parameter
          class):role1|role2|...</para>

          <para>Parameters where method takes two or more:</para>

          <para>&lt;fully qualified class&gt;#&lt;method&gt;(fully qualified
          parameter class1, fully qualified parameter class2,
          ...):role1|role2|...</para>

          <para>Each line in the file is a separate match.</para>

          <para>So, for example, in the white list file</para>

          <programlisting format="linespecific">com.nakedobjectsgroup.expenses.services.hibernate.ClaimRepositoryHibernate:role1 </programlisting>

          <para>will permit all actions/properties on <literal
          moreinfo="none">com.nakedobjectsgroup.expenses.services.hibernate.ClaimRepositoryHibernate</literal>
          for role1</para>

          <programlisting format="linespecific">com.nakedobjectsgroup.expenses.services.hibernate.
    ClaimantRepositoryHibernate#findClaimantByName:role1|role2</programlisting>

          <para>will permit all overloaded methods named <literal
          moreinfo="none">findClaimantByName</literal> on <literal
          moreinfo="none">com.nakedobjectsgroup.expenses.services.hibernate.ClaimantRepositoryHibernate</literal>
          for role1 and role2 and</para>

          <programlisting format="linespecific">com.nakedobjectsgroup.expenses.services.hibernate.ClaimantRepositoryHibernate#findClaimantByIdentifier(java.lang.String):role3</programlisting>

          <para>will permit <literal
          moreinfo="none">findClaimantByIdentifier</literal> with parameter
          <literal moreinfo="none">java.lang.String</literal> on <literal
          moreinfo="none">com.nakedobjectsgroup.expenses.services.hibernate.ClaimantRepositoryHibernate</literal>
          for role3. In each case an identical entry in the black list file
          will instead make the action or property unavailable. The
          combination of white and black list allows some economy in the
          settings. For example, if all but one method of a large class is to
          be allowed, that could be configured with one entry per method in
          the white list file or, better, a single entry for the class in the
          white list and a single entry for the unavailable method in the
          black list.</para>
        </sect2>

        <sect2>
          <title>Authorization through LDAP server</title>

          <para>To enable authorization by LDAP server include facet for
          authorization and specifying the <literal
          moreinfo="none">ldap</literal> implementation for
          authorization.</para>

          <programlisting format="linespecific">nakedobjects.reflector.facets.include=\
    org.nakedobjects.runtime.authorization.standard.AuthorizationFacetFactoryImpl
nakedobjects.authorization=ldap</programlisting>

          <para>With LDAP authorization the current user's role will be
          authorised against an entry in the LDAP server for each method
          possibly available to them. The URL of the server is obtained from
          the same property as for authentication.</para>

          <para>The authorization entries should exist under a DN configured
          in the property file. For example.</para>

          <programlisting format="linespecific">nakedobjects.authorization.ldap.application.dn= cn=expenses, dc=apps, dc=nakedobjects, dc=org </programlisting>

          <para>This will be checked anonymously.</para>

          <para>Entries to be matched against should exist under this dn.
          Expected configuration is a hierarchy of class, method and
          parameters. The cn of each entry is expected to be the fully
          qualified class name, method or parameter list ('()' for an empty
          parameter list). If an entry has a 'uniquemember' attribute equal to
          'role' then that entry and all sub-entries are authorised.</para>

          <para>For example</para>

          <para>DN:
          cn=com.nakedobjectsgroup.expenses.services.hibernate.ClaimRepositoryHibernate,
          cn=expenses, dc=apps, dc=nakedobjects, dc=org</para>

          <para>with uniquemember = role1 will authorise all members of
          <literal
          moreinfo="none">com.nakedobjectsgroup.expenses.services.hibernate.ClaimRepositoryHibernate</literal>
          for users with role1.</para>

          <para>DN: cn=(com.nakedobjectsgroup.expenses.claimant.Claimant,
          java.lang.String),</para>

          <para>cn=createNewClaim,
          cn=com.nakedobjectsgroup.expenses.services.hibernate.ClaimRepositoryHibernate,
          cn=expenses, dc=apps, dc=nakedobjects, dc=org</para>

          <para>with uniquemember = role1 will authorise the <literal
          moreinfo="none">createNewClaim(com.nakedobjectsgroup.expenses.claimant.Claimant,
          String)</literal> member of <literal
          moreinfo="none">com.nakedobjectsgroup.expenses.services.hibernate.ClaimRepositoryHibernate</literal>
          for users with role1.</para>
        </sect2>

        <sect2>
          <title>Authorization through database</title>

          <para>To enable authorization through a database table
          specify:</para>

          <programlisting format="linespecific">nakedobjects.reflector.facets.include=\
    org.nakedobjects.runtime.authorization.standard.AuthorizationFacetFactoryImpl
nakedobjects.authorization=database</programlisting>

          <para>In the same way as database authentication, database
          authorization is dependent upon hibernate. The authorization table
          should exist in the database configured in the hibernate.cfg.xml
          settings. By default this will check against a permissions table
          described as follows.</para>

          <programlisting format="linespecific">CREATE TABLE permissions (id INTEGER  NOT NULL, role INTEGER  NOT NULL,permission VARCHAR(255) NOT NULL, flags INTEGER, PRIMARY KEY (id));</programlisting>

          <para>The functionality is the same as for white list file matching
          described above, where the permission field in the table contains
          the signature to match.</para>
        </sect2>

        <sect2>
          <title>Separate visibility and usability authorization</title>

          <para>There is an optional capability to authorise the visibility
          and usability of fields independently. Thus a field may be visible
          to certain roles but not editable. In order to configure this
          against a authorization a flag must be added as follows.</para>

          <sect3>
            <title>File authorization</title>

            <para>Add a "-rw" suffix to any role in the allow or disallow
            files. "-rw" will match (and hence allow in the allow file,
            disallow in the disallow file) edit authorization requests.</para>
          </sect3>

          <sect3>
            <title>Database authorization</title>

            <para>Populate the flags column in the permissions table with the
            value 0 (for read/write) or 1 (for read only).</para>
          </sect3>

          <sect3>
            <title>Ldap authorization</title>

            <para>Add a flags attribute to the entry with the role. If it's
            set to 'rw' editing will be allowed, any other value (typically
            'ro') will disallow editing.</para>

            <para>In each case absence of the flag will mean that visibility
            and usability and are always the same.</para>
          </sect3>
        </sect2>

        <sect2>
          <title>Capturing authorization requirements automatically</title>

          <para>As a tool for helping to configure the initial security
          settings there is a 'learn' property.</para>

          <programlisting format="linespecific">nakedobjects.authorization.learn=true</programlisting>

          <para>When this is present and set, all methods will be authorised
          for all roles. However as each method is accessed through the user
          interface authorization will be configured for that method and the
          current role. Configuration will be saved in either the file (saved
          on shutdown), database table or LDAP security settings depending
          upon the reflector setup.</para>

          <para>The settings can then be modified to conform to the required
          security settings.</para>
        </sect2>
      </sect1>
    </chapter>
  </part>

  <part id="reference1">
    <title>Reference - Programming model definition</title>

    <chapter id="recognised-types">
      <title>Recognised Types</title>

      <para>Naked Objects creates an adapter for every domain object. There
      are three categories of objects that are recognised: value, reference
      and collection. Value and collection objects are dealt with on a class
      by class basis, while all reference objects are dealt with in the same
      way where the properties are seen as fields, and public methods as
      actions. Listed below are all the recognised types.</para>

      <sect1>
        <title>Value objects</title>

        <para>The following are built-in types. In addition to these any type
        either annotated using <classname>@Value</classname>, or registered as
        a value type using <filename>nakedobjects.properties</filename>, will
        also be treated as a value type.</para>

        <sect2>
          <title>Primitive types</title>

          <itemizedlist>
            <listitem>
              <para><literal moreinfo="none">boolean</literal></para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">byte</literal></para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">char</literal></para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">double</literal></para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">float</literal></para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">int</literal></para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">long</literal></para>
            </listitem>

            <listitem>
              <para><literal moreinfo="none">short</literal></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Number classes</title>

          <itemizedlist>
            <listitem>
              <para><classname>java.lang.Boolean</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.math.BigInteger</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.math.BigDecimal</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.lang.Byte</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.lang.Character</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.lang.Double</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.lang.Float</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.lang.Integer</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.lang.Long</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.lang.Short</classname></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Java Classes</title>

          <itemizedlist>
            <listitem>
              <para><classname>java.lang.String</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.util.Date</classname> (date and
              time)</para>
            </listitem>

            <listitem>
              <para><classname>java.sql.Date</classname> (date only)</para>
            </listitem>

            <listitem>
              <para><classname>java.sql.Time</classname> (time only)</para>
            </listitem>

            <listitem>
              <para><classname>java.sql.Timestamp</classname></para>
            </listitem>

            <listitem>
              <para><classname>java.awt.Image</classname></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Application Library</title>

          <itemizedlist>
            <listitem>
              <para><classname>org.nakedobjects.applib.value.Color</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.Date</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.DateTime</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.Image</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.Money</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.Password</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.Percentage</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.Time</classname></para>
            </listitem>

            <listitem>
              <para><classname>org.nakedobjects.applib.value.TimeStamp</classname></para>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>

      <sect1>
        <title>Collection objects</title>

        <itemizedlist>
          <listitem>
            <para><classname>java.util.Collection</classname> (usually
            <classname>java.util.ArrayList</classname>,
            <code>java.util.LinkedList</code>,
            <classname>java.util.LinkedHashSet</classname> or
            <classname>java.util.TreeSet</classname>)</para>
          </listitem>

          <listitem>
            <para>arrays</para>
          </listitem>
        </itemizedlist>

        <para>Note that <classname>java.util.Map</classname> is not supported
        as a collection type.</para>
      </sect1>

      <sect1>
        <title>Reference objects</title>

        <itemizedlist>
          <listitem>
            <para>all other domain classes (not annotated with
            <literal>@Value</literal> / registered as a value using
            <filename>nakedobjects.properties</filename>).</para>
          </listitem>
        </itemizedlist>
      </sect1>
    </chapter>

    <chapter id="recognised-methods" label="">
      <title>Recognised Methods</title>

      <para>The Java 1.5 reflector allows the domain modeller to define
      behaviourally complete domain objects, provide maximum feedback to the
      user, and control any interaction that may take place (rather than place
      that code in each and every user interface and back-end). This sections
      lists the explicit methods that are recognised by the standard
      reflector. All methods must be <code>public</code> to be
      recognised.</para>

      <para>Methods that do not get matched with any of the listed rules are
      deemed to be action methods that we expect the user to invoke via the
      user interface. These are public methods, of the following format</para>

      <programlisting format="linespecific">public void &lt;actionName&gt;([&lt;property type&gt; param]...)
public &lt;type&gt; &lt;actionName&gt;([&lt;property type&gt; param]...)</programlisting>

      <para>that are not used for fields, titles, or for controlling other
      methods. Essentially they are the methods left over from generating all
      other aspects of the class.</para>

      <para>When such a method returns a reference the framework will attempt
      to display that object. If an action method returns <literal
      moreinfo="none">null</literal> then nothing will be displayed.</para>

      <sect1 id="addto-method">
        <title>addTo</title>

        <programlisting format="linespecific">public void addTo&lt;PropertyName&gt;(&lt;collection element type&gt; param)</programlisting>

        <para>Used in conjunction with a collection, the <literal
        moreinfo="none">addTo</literal> method is called by the framework when
        the user adds an element to the collection. By providing this method
        in conjunction with a non-generic collection it will be limited to a
        specific type (rather than being used to store references of type
        <classname>Object</classname>). This behaviour is similar to that of
        the <methodname>modify</methodname> method for properties.</para>

        <para>See also <xref linkend="modify-method" /> and <xref
        linkend="removefrom-method" /></para>
      </sect1>

      <sect1>
        <title>choices</title>

        <bridgehead>On a property</bridgehead>

        <programlisting format="linespecific">public &lt;property type&gt;[] choices&lt;PropertyName&gt;([&lt;property type&gt; param])

public List&lt;property type&gt; choices&lt;PropertyName&gt;([&lt;property type&gt; param])</programlisting>

        <para>Used in conjunction with a property, the
        <methodname>choices</methodname> method provides the user with a set
        of options for setting a property. This method is called when the user
        interface makes the options available, hence its return value can be
        based on the current state of the object. Note - this does not limit
        the state of the field, see the <methodname>validate</methodname>
        methods for a way to do that.</para>

        <bridgehead>On parameters on an action</bridgehead>

        <para>Either:</para>

        <programlisting format="linespecific">public Object[] choicesN&lt;actionName&gt;()

public List&lt;parameter type&gt; choicesN&lt;parameterNumber&gt;&lt;actionName&gt;()</programlisting>

        <para>where N is the 0-based parameter number.</para>

        <para>Or:</para>

        <programlisting format="linespecific">public Object[] choices&lt;actionName&gt;([&lt;parameter type&gt; param]...)

public List&lt;parameter type&gt; choices&lt;parameterNumber&gt;&lt;actionName&gt;([&lt;parameter type&gt; param])</programlisting>

        <para>Complements an action method, or a specific paramter within an
        action.</para>

        <para>The <methodname>choices</methodname> method provides a set of
        options for the parameters of an action. This method is called when
        the user interface prompts for the parameters from the user, so the
        options cannot depend on the state of any of the other parameters.
        Note - this does not limit the state of the parameter, see the
        <methodname>validate</methodname> methods for a way to do that.</para>

        <para>For each parameter the array should contain either <literal
        moreinfo="none">null</literal>, an array, or a collection.</para>
      </sect1>

      <sect1>
        <title id="clear-method">clear</title>

        <programlisting format="linespecific">public void clear&lt;PropertyName&gt;()</programlisting>

        <para>Used in conjunction with a property, the
        <methodname>clear</methodname> method is called when the user (rather
        than the framework) clears a reference field, or blanks (so there is
        no entry) a value field.</para>

        <para>See also <xref linkend="modify-method" /></para>
      </sect1>

      <sect1>
        <title>created</title>

        <programlisting format="linespecific">public void created()</programlisting>

        <para>Life cycle method called by framework when an object is first
        created. This is the instance's logical creation. This method will
        <emphasis>not</emphasis> be called when the object is recreated during
        persistence or remoting.</para>
      </sect1>

      <sect1>
        <title>default</title>

        <bridgehead>For a property</bridgehead>

        <programlisting format="linespecific">public &lt;parameter type&gt; default&lt;actionName&gt;([&lt;parameter type&gt; param]...)</programlisting>

        <para>Complements a get/set method for a reference or value
        property.</para>

        <para>Provides the default reference or value for a property to be set
        to when an object is first created, or the user asks for a property to
        be reset.</para>

        <bridgehead>For parameters on an action</bridgehead>

        <para>Either:</para>

        <programlisting format="linespecific">public Object[] defaultN&lt;actionName&gt;()

public List&lt;parameter type&gt; defaultN&lt;parameterNumber&gt;&lt;actionName&gt;()</programlisting>

        <para>where N is the 0-based parameter number.</para>

        <para>Or:</para>

        <programlisting format="linespecific">public Object[] default&lt;actionName&gt;([&lt;parameter type&gt; param]...)

public List&lt;parameter type&gt; default&lt;parameterNumber&gt;&lt;actionName&gt;([&lt;parameter type&gt; param])</programlisting>

        <para>Complements an action method, or a specific parameter on an
        action method.</para>

        <para>Provides the defaults that should be used for the parameters
        expected by an action method. The values should be provided as an
        array with the same number of elements as the number of parameters.
        Any parameter that does not have a default should have its
        corresponding element in the array set to null.</para>
      </sect1>

      <sect1>
        <title>deleted</title>

        <para>Deprecated but still supported; replaced by
        <methodname>removed()</methodname></para>

        <programlisting format="linespecific">public void deleted()</programlisting>

        <para>Life cycle method called by framework when an object has just
        been removed from the persistent store. At this point the object will
        exist in memory, but no longer exist in the persistent store.</para>
      </sect1>

      <sect1>
        <title>deleting</title>

        <para>Deprecated but still supported; replaced by
        <methodname>removing()</methodname></para>

        <programlisting format="linespecific">public void deleting()</programlisting>

        <para>Life cycle method called by framework when an object is just
        about to be removed from the persistent store. At this point the
        object still exists in the persistent store.</para>
      </sect1>

      <sect1>
        <title>disable</title>

        <programlisting format="linespecific">public String disable&lt;PropertyName&gt;([&lt;property type&gt; param])

public String disable&lt;actionName&gt;([&lt;parameter type&gt; param]...)</programlisting>

        <para>Complements a get/set method for a field, or an action
        method.</para>

        <para>The <literal moreinfo="none">disable</literal> dynamically
        controls whether a field is editable, or an action can be initiated.
        If a <classname>String</classname> object is returned the field or
        action is disabled and the string is made visible to user to inform
        them why it is disabled. If the method returns <literal
        moreinfo="none">null</literal> then field or action remains
        enabled.</para>
      </sect1>

      <sect1>
        <title>get</title>

        <bridgehead>Value or reference property</bridgehead>

        <programlisting format="linespecific">public &lt;property type&gt; get&lt;PropertyName&gt;()</programlisting>

        <para>A standard JavaBean accessor/mutator pair will be recognised as
        a field for a value or reference. Values include Java primitives,
        <classname>String</classname>s and <classname>Date</classname>s, and
        also the value types provided by the Naked Objects application library
        (see the section on <xref linkend="recognised-types" />).</para>

        <para>If there is no mutator method then the field is flagged as being
        derived and will not be persisted or editable.</para>

        <bridgehead>Collection property</bridgehead>

        <para>A collection is picked up via an accessor method with the
        following signature. Java arrays, <classname>Vector</classname>s and
        <classname>List</classname>s (including generic lists) are the only
        types that are recognised at the moment.</para>

        <programlisting format="linespecific">public &lt;collection type&gt; get&lt;PropertyName&gt;()</programlisting>
      </sect1>

      <sect1>
        <title>getId</title>

        <programlisting>public String getId()</programlisting>

        <para>The <methodname>getId</methodname> method is used by service
        objects to provide an identity for a particular service type. This
        should be the same for all implementations of a specific service
        allowing them to be swapped for one another.</para>
      </sect1>

      <sect1>
        <title>hide</title>

        <programlisting format="linespecific">public boolean hide&lt;PropertyName&gt;([&lt;property type&gt; param])

public boolean hide&lt;actionName&gt;([&lt;parameter type&gt; param]...)</programlisting>

        <para>Complements a get/set method for a field, or an action
        method.</para>

        <para>The <literal moreinfo="none">hide</literal> method allows a
        property or action to be dynamically hidden from the user. This is
        typically used for security reasons, such as hiding a field once it is
        set up. Returning <literal moreinfo="none">true</literal> makes the
        property or action invisible.</para>
      </sect1>

      <sect1>
        <title>iconName</title>

        <programlisting format="linespecific">public String iconName()</programlisting>

        <para>The <literal moreinfo="none">iconName</literal> is used to
        over-ride the framework's default mechanism for determining the icon
        to display based on the class name. The name returned by this method
        should be simply a name and not a filepath: it should not have an file
        extension. The framework will look for an acceptable type of image
        using this name, deriving possible filenames from it. See the section
        on <xref linkend="images" /> for more information.</para>
      </sect1>

      <sect1>
        <title>loaded</title>

        <programlisting format="linespecific">public void loaded()</programlisting>

        <para>Life cycle method called by framework when an object has just
        been loaded in from the persistent store. At this point the object has
        it's correct persisted state.</para>
      </sect1>

      <sect1>
        <title>loading</title>

        <programlisting format="linespecific">public void loading()</programlisting>

        <para>Life cycle method called by framework when an object is just
        about to be loaded from the persistent store. At this point the object
        exists in memory but has not had its state restored.</para>
      </sect1>

      <sect1 id="modify-method">
        <title>modify</title>

        <programlisting format="linespecific">public void modify&lt;PropertyName&gt;(&lt;property type&gt; param)</programlisting>

        <para>Complements a property.</para>

        <para>The <literal moreinfo="none">modify</literal> method is called
        when the user (rather than the framework) sets a reference or value
        field. This is typically used to initialise an association (where an
        association is combination of references, such as a back link), or to
        trigger other behaviours such as adding the new value to a
        total.</para>

        <para>See also <xref linkend="clear-method" />.</para>
      </sect1>

      <sect1>
        <title>persisted</title>

        <para>Replaces <methodname>saved()</methodname></para>

        <programlisting format="linespecific">public void persisted()</programlisting>

        <para>Life cycle method called by framework when a transient object
        has just been added to the persistent store. At this point the object
        exists in the persistent store.</para>
      </sect1>

      <sect1>
        <title>persisting</title>

        <para>Replaces <methodname>saving()</methodname></para>

        <programlisting format="linespecific">public void persisting()</programlisting>

        <para>Life cycle method called by framework when a transient object is
        just about to be added to the persistent store. At this point the
        object exists only in memory and not in the persistent store.</para>
      </sect1>

      <sect1>
        <title>removed</title>

        <para>Replaces <methodname>deleted()</methodname></para>

        <programlisting format="linespecific">public void removed()</programlisting>

        <para>Life cycle method called by framework when an object has just
        been removed from the persistent store. At this point the object will
        exist in memory, but no longer exist in the persistent store.</para>
      </sect1>

      <sect1>
        <title>removing</title>

        <para>Replaces <methodname>deleting()</methodname></para>

        <programlisting format="linespecific">public void removing()</programlisting>

        <para>Life cycle method called by framework when an object is just
        about to be removed from the persistent store. At this point the
        object still exists in the persistent store.</para>
      </sect1>

      <sect1 id="removefrom-method">
        <title>removeFrom</title>

        <programlisting format="linespecific">public void removeFrom&lt;PropertyName&gt;(&lt;property type&gt; param)</programlisting>

        <para>Complements a collection.</para>

        <para>The <literal moreinfo="none">removeFrom</literal> method is
        called by the framework when the user removes an element from the
        collection. By providing this method in conjunction with a non-generic
        collection interactions with that collection become limited to a
        specific type (rather than being used to store references of type
        <classname>Object</classname>). This signature is similar to the
        <literal moreinfo="none">clear</literal> method for properties.</para>

        <para>See also <xref linkend="clear-method" /> and <xref
        linkend="addto-method" />.</para>
      </sect1>

      <sect1>
        <title>saved</title>

        <para>Deprecated but still supported; replaced by
        <methodname>persisted()</methodname></para>

        <programlisting format="linespecific">public void saved()</programlisting>

        <para>Life cycle method called by framework when a transient object
        has just been added to the persistent store. At this point the object
        exists in the persistent store..</para>
      </sect1>

      <sect1>
        <title>saving</title>

        <para>Deprecated but still supported; replaced by
        <methodname>persisting()</methodname></para>

        <programlisting format="linespecific">public void saving()</programlisting>

        <para>Life cycle method called by framework when a transient object is
        just about to be added to the persistent store. At this point the
        object exists only in memory and not in the persistent store.</para>
      </sect1>

      <sect1>
        <title>set</title>

        <programlisting format="linespecific">public void set&lt;PropertyName&gt;(&lt;property type&gt; param)</programlisting>

        <para>Complements a <code>get</code> method.</para>

        <para>The <literal moreinfo="none">set</literal> method is called when
        the property is changed, either by the user or the framework. As the
        framework calls the same method when recreating the object from
        persistent data it is important to avoid doing any work in the
        <code>set</code> method other than setting up the property variable. A
        typical set method would be:</para>

        <programlisting format="linespecific">private String name;

public void setName(String name) {
    this.name = name;
}</programlisting>
      </sect1>

      <sect1>
        <title>toString</title>

        <programlisting format="linespecific">public String toString()</programlisting>

        <para>The <methodname>toString</methodname> method is used to get a
        title for the object. If the <code>toString</code> method cannot serve
        as the title, because it is being used for alternative purposes (such
        as debugging) then you may define a <code>title</code> method instead
        (below).</para>
      </sect1>

      <sect1>
        <title>title</title>

        <programlisting format="linespecific">public String title()</programlisting>

        <para>If a <methodname>title</methodname> method is defined then the
        framework will use this in preference to the
        <methodname>toString</methodname> method for displaying the object's
        title.</para>
      </sect1>

      <sect1>
        <title>updated</title>

        <programlisting format="linespecific">public void updated()</programlisting>

        <para>Life cycle method called by framework when a modified persistent
        object has just been saved to the persistent store. At this point the
        object's state in the persistent store will be in its new
        state.</para>
      </sect1>

      <sect1>
        <title>updating</title>

        <programlisting format="linespecific">public void updating()</programlisting>

        <para>Life cycle method called by framework when a persistent object
        has just been modified and is about to be saved to the persistent
        store. At this point the object's state in the persistent store will
        still be in its pre-modified state.</para>
      </sect1>

      <sect1>
        <title>validate</title>

        <bridgehead>Ensure value or reference is valid</bridgehead>

        <programlisting format="linespecific">public String validate&lt;PropertyName&gt;(&lt;property type&gt; param)</programlisting>

        <para>Complements a get/set method for a value or reference
        property.</para>

        <para>This <methodname>validate</methodname> method is used to check
        the value/reference that is to be used to set a property. Using such a
        mechanism the programmer can guarantee that a field never becomes
        invalid. If a <classname>String</classname> object is returned the
        value/reference is consider to be invalid and the field will not be
        set. The string itself will then be made visible to the user to inform
        them why it is invalid. If the method returns <literal
        moreinfo="none">null</literal> then property will be set, that is, its
        <methodname>set</methodname> or <methodname>modify</methodname> method
        will be called with the same parameter.</para>

        <bridgehead>Ensure collection can have an element added or
        removed</bridgehead>

        <programlisting format="linespecific">public String validateAddTo&lt;PropertyName&gt;(&lt;property type&gt; param)
public String validateRemoveFrom&lt;PropertyName&gt;(&lt;property type&gt; param)</programlisting>

        <para>Complements a get method for a collection property.</para>

        <para>This <methodname>validate</methodname> method is used to check
        that the specified object can be added to or removed from a
        collection. Using such a mechanism the programmer can guarantee that
        the collection never becomes invalid. If a
        <classname>String</classname> object is returned then adding/removing
        the specified object is not valid and the collection will not be
        changed. The string itself will then be made visible to the user to
        inform them why changing the collection with the object would be
        invalid. If the method returns <literal moreinfo="none">null</literal>
        then the object will be added to/removed from the collection, that is,
        from the collection object directly if there is no
        <methodname>addTo</methodname>/<methodname>removeFrom</methodname>
        method, or via a call to the
        <methodname>addTo</methodname>/<methodname>removeFrom</methodname>
        method, with the same parameter, if they do exist.</para>

        <bridgehead>Ensure it is valid to invoke an action</bridgehead>

        <programlisting format="linespecific">public String validate&lt;actionName&gt;([&lt;parameter type&gt; param]...)</programlisting>

        <para>Complements an action method.</para>

        <para>This <methodname>validate</methodname> method is used to check
        that the actions parameters are all valid and that the action method
        can be safely invoked, that is, if it is invoked that it will not
        fail. If a <classname>String</classname> object is returned then the
        action should not be invoked. The string itself will then be made
        visible to the user to inform them why the method cannot be invoked.
        If the method returns <literal moreinfo="none">null</literal> then the
        action method will be invoked with the same set of parameters.</para>

        <bridgehead>Ensure object is in a valid state to be saved</bridgehead>

        <para>A validate() method may be added to provided validation at
        object level - prior to making an object persistent.</para>

        <programlisting>public String validate()</programlisting>

        <para>This is particularly useful for validating fields in relation to
        each other, as in the following example:</para>

        <programlisting>public class Booking {
    private Date fromDate;
    public Date getFromDate() {...}
    public void setFromDate(Date d) {...}
    
    private Date toDate;
    public Date getToDate() {...}
    public void setToDate(Date d) {...}

    public String validate() {
        if (fromDate &gt; toDate) {
            return "From Date cannot be after To Date";
        }
        return null;
    }
    ...
}</programlisting>

        <para>This will prevent the user from saving a transient
        <code>Booking</code> where the From Date falls after the To Date. Note
        that in this example, the two date properties could also have their
        own individual validate methods - for example in order to test that
        each date was after today.</para>

        <warning>
          <para>At the time of writing, the <code>validate</code> method is
          called only when the object is first saved, not when it is
          subsequently updated. For validation of subsequent updates, it is
          necessary to build the validation logic into the individual property
          validation methods, though these could delegate to a common
          <code>validate</code> method.</para>
        </warning>
      </sect1>
    </chapter>

    <chapter>
      <title>Recognised Annotations</title>

      <para>This section defines the set of annotations that are recognised by
      the Naked Objects Java Programming Model.</para>

      <sect1>
        <title>@ActionOrder</title>

        <para>Note: The recommended mechanism for specifying the order in
        which actions are listed to the user is <code>@MemberOrder</code> (see
        below). <code>@ActionOrder</code> provides an alternative mechanism,
        in which the order is specified in one place in the class, with the
        added advantage (currently) that you can easily specify groupings
        (which may be rendered by the viewer as sub-menus). However,
        <code>@ActionOrder</code> is more 'brittle' to change: if you change
        the name of an existing action you will need to ensure that the
        corresponding name within the <code>@ActionOrder</code> annotation is
        also changed.</para>

        <para>The syntax is: <literal moreinfo="none">@ActionOrder("&lt;comma
        separated list of action names&gt;")</literal> (the action names are
        not case sensitive).</para>

        <para>For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@ActionOrder("PlaceNewOrder, CheckCredit")</emphasis>
public class Customer {

    public Order placeNewOrder() {}

    public CreditRating checkCredit() {}

...
}</programlisting>

        <para>Actions can be grouped together by surrounding the group with
        brackets, and prefixing the group with name and colon. This
        information may be used by the viewing mechanism to render actions
        into sub-menus. For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@ActionOrder("(Account Management: PlaceOrder, CheckCredit), (Personal Details: ChangeOfAddress, AddEmail)")</emphasis>
public class Customer {

    public Order placeNewOrder() {}

    public CreditRating checkCredit() {}

    public void changeOfAddress() {}

    public void addEmail(String emailAddress) {}

    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@Bounded</title>

        <para>For immutable objects where there is a bounded set of instances,
        the <literal moreinfo="none">@Bounded</literal> annotation can be
        used. For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Bounded</emphasis>
public class County {
    // members and actions here
}</programlisting>

        <para>The number of instances is expected to be small enough that all
        instance can be held in memory. The viewer will use this information
        to render all the instances of this class in a drop-down list or
        equivalent. (Note: Although this is not enforced, <literal
        moreinfo="none">@Bounded</literal> is intended for use on <literal
        moreinfo="none">final</literal> classes. Its behaviour when used on
        interfaces, or classes with sub-classes is not specified).</para>
      </sect1>

      <sect1>
        <title>@Debug</title>

        <para>The <classname>@Debug </classname>annotation marks an action
        method as available in debug mode only, and so will not normally be
        displayed by the user interface.</para>
      </sect1>

      <sect1>
        <title>@DescribedAs</title>

        <para>The <literal moreinfo="none">@DescribedAs</literal> annotation
        is used to provide a short description of something that features on
        the user interface. How this description is used will depend upon the
        viewing mechanism - but it may be thought of as being like a 'tool
        tip'. Descriptions may be provided for objects, members (properties,
        collections and actions), and for individual parameters within an
        action method. <literal moreinfo="none">@DescribedAs</literal>
        therefore works in a very similar manner to <literal
        moreinfo="none">@Named</literal>.</para>

        <bridgehead>Providing a description for an object</bridgehead>

        <para>To provide a description for an object, use the <literal
        moreinfo="none">@DescribedAs</literal> annotation immediately before
        the declaration of that object class. For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@DescribedAs("A Customer who may have originally become known to us via " +
             "the marketing system or who may have contacted us directly.")</emphasis>
public class ProspectiveSale {
   ...
}</programlisting>

        <bridgehead>Providing a description for a member</bridgehead>

        <para>Any member (property, collection or action) may provide a
        description. To specify this description, use the <literal
        moreinfo="none">@DescribedAs</literal> annotation immediately before
        the declaration of that member. For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@DescribedAs("The name that the customer has indicated that they wish to be " +
                 "addressed as (e.g. Johnny rather than Jonathan)")</emphasis>
    public String getFirstName() { ... }
}</programlisting>

        <bridgehead>Providing a description for an action
        parameter</bridgehead>

        <para>To provide a description for an individual action parameter, use
        the <literal moreinfo="none">@DescribedAs</literal> annotation in-line
        i.e. immediately before the parameter declaration. For example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity")
                      <emphasis role="strong">@DescribedAs("The quantity of the product being ordered")</emphasis>
                      int quantity) {

        Order order = new Order();
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@Disabled</title>

        <para>The <literal moreinfo="none">@Disabled</literal> annotation
        means that the member cannot be used in any instance of the class.
        When applied to the property it means that the user may not modify the
        value of that property (though it may still be modified
        programmatically). When applied to an action method, it means that the
        user cannot invoke that method. For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>
    public void assessCreditWorthiness() { ... }

    <emphasis role="strong">@Disabled</emphasis>
    public int getInitialCreditRating(){ ... }
    public void setInitialCreditRating(int initialCreditRating) { ... }
}</programlisting>

        <para>Note that if an action is marked as <literal
        moreinfo="none">@Disabled</literal>, it will be shown on the user
        interface but cannot ever be invoked. One possible reason to do this
        is during prototyping, to indicate an action that is still to be
        developed. If a method is intended for programmatic use, but not
        intended ever to be invoked directly by a user, then it should be
        marked as <literal moreinfo="none">@Hidden</literal> instead.</para>

        <para>This annotation can also take a single parameter indicating when
        it is to be hidden, for example the following code would disable the
        action until the object has been saved.</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>(When.UNTIL_PERSISTED)
    public void assessCreditWorthiness() { ... }
}</programlisting>

        <para>The acceptable values for the parameter are:
        <code>When.ALWAYS</code>, <code>When.NEVER</code>,
        <code>When.ONCE_PERSISTED</code> and
        <code>When.UNTIL_PERSISTED</code>. By default the annotated property
        or action is always disabled i.e. it is implicitly
        <code>When.ALWAYS.</code></para>
      </sect1>

      <sect1>
        <title>@Executed</title>

        <para>The <classname>@Executed</classname> annotation overrides the
        default location where a method is executed.</para>

        <bridgehead>Forcing a method to be executed on the client</bridgehead>

        <para>The <classname>@Executed(Where.LOCALLY)</classname> annotation
        marks an action method so that it executes on the client, rather than
        being forwarded to the server for execution. This is useful for
        methods that invoke a service that must be run client-side, for
        example spawning off a separate process (such as a web browser or
        Acrobat Reader).</para>

        <bridgehead>Forcing a method to be executed on the server</bridgehead>

        <para>The <classname>@Executed(Where.REMOTELY)</classname> annotation
        marks an action method so that it executes on the server, even though
        it would normally be executed on the client (as methods for transient
        objects are). This is useful for methods that although based on
        transient objects need access to persistent objects.</para>
      </sect1>

      <sect1>
        <title>@Exploration</title>

        <para>The <classname>@Exploration</classname> annotation marks an
        action method as available in exploration mode only, and therefore not
        intended for use in the production system</para>
      </sect1>

      <sect1>
        <title>@FieldOrder</title>

        <para>Note: The recommended mechanism for specifying the order in
        which fields are listed to the user is <code>@MemberOrder</code> (see
        below). <code>@FieldOrder</code> provides an alternative mechanism, in
        which the order is specified in one place in the class. However,
        <code>@FieldOrder</code> is more 'brittle' to change: if you change
        the name of an existing property you will need to ensure that the
        corresponding name within the <code>@FieldOrder</code> annotation is
        also changed.</para>

        <para>The syntax is: <literal moreinfo="none">@FieldOrder("&lt;comma
        separated list of field names&gt;") </literal>(the field names are not
        case sensitive.).</para>

        <para>For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@FieldOrder("Name, Address, DateOfBirth, RecentOrders")</emphasis>
public class Customer {

    public Date getDateOfBirth() {...}

    public List&lt;Order&gt; getRecentOrders() {...}

    public String getAddress() {...}

    public String getName() {...}

    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@Hidden</title>

        <para>The <literal moreinfo="none">@Hidden</literal> annotation
        indicates that the member (property, collection or action) to which it
        is applied should never be visible to the user. For example:</para>

        <programlisting format="linespecific">public class Customer {
    private int internalId;

    <emphasis role="strong">@Hidden</emphasis>
    public int getInternalId() {
        return internalId;
    }

    <emphasis role="strong">@Hidden</emphasis>
    public void updateStatus() { ... }
}</programlisting>

        <para>This annotation can also take a single parameter indicating when
        it is to be hidden, for example the following code would show the Id
        until the object has been saved, and then would hide it.</para>

        <programlisting format="linespecific">public class Customer {
    private int internalId;

    <emphasis role="strong">@Hidden</emphasis>(When.ONCE_PERSISTED)
    public int getInternalId() {
        return internalId;
    }
}</programlisting>

        <para>The acceptable values for the parameter are:
        <code>When.ALWAYS</code>, <code>When.NEVER</code>,
        <code>When.ONCE_PERSISTED</code> and
        <code>When.UNTIL_PERSISTED</code>. By default the annotated property
        or action is always hidden i.e. it is implicitly
        <code>When.ALWAYS.</code></para>
      </sect1>

      <sect1>
        <title>@Immutable</title>

        <para>The <literal moreinfo="none">@Immutable</literal> annotation may
        be applied to a class. The framework does not allow the state of such
        objects to be changed through the UI, and it should be considered a
        programmer error to do so programmatically. The ObjectStorePersistor,
        as used to run the in-memory and Hibernate object stores will actually
        fail if the programmer tries to change an object in a way that cause
        the persistor to try and save it. For example the following class
        would prevent the user from changing the object even when
        transient:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Immutable</emphasis>
public class Country {
    ...
}</programlisting>

        <para>This annotation can also take a single parameter indicating when
        it is to become immutable, for example the following code would allow
        the user to create an email object and set it up, and then prevent any
        changes once it has been saved.</para>

        <programlisting format="linespecific"><emphasis role="strong">@Immutable</emphasis>(When.ONCE_PERSISTED)
public class Email {
    ...
}</programlisting>

        <para>The acceptable values for the parameter are:
        <code>When.ALWAYS</code>, <code>When.NEVER</code>,
        <code>When.ONCE_PERSISTED</code> and
        <code>When.UNTIL_PERSISTED</code>. By default the annotated property
        or action is always immutable i.e. it is implicitly
        <code>When.ALWAYS.</code></para>
      </sect1>

      <sect1>
        <title id="mask-annotation">@Mask</title>

        <para>The <literal moreinfo="none">@Mask </literal>annotation may be
        applied to any property, or to any parameter within an action method,
        that allows the user to type in text as input. The mask serves to
        validate, and potentially to normalise, the format of the input. The
        characters that can be used are based on Swing's MaskFormatter, and
        also Java's SimpleDateFormat. When applying a mask to a value
        property, the annotation should be applied to the 'getter'. For
        example:</para>

        <programlisting format="linespecific">public class Email {
    private String telNo;

    <emphasis role="strong">@Mask("(NNN)NNN-NNNN")</emphasis>
    public String getTelephoneNumber() {...}

    public void setTelephoneNumber(String telNo) {...}
    ...
}</programlisting>

        <para>When applying a mask to a value parameter within an action
        method, the annotation should be applied 'in-line' before that
        parameter). For example:</para>

        <programlisting format="linespecific">public void newContact(
     @Named("Contact Name")
     String contactName,
     @Named("Telephone Number")
     <emphasis role="strong">@Mask("(NNN)NNN-NNNN")</emphasis>
     String telNo) {}</programlisting>
      </sect1>

      <sect1>
        <title>@MaxLength</title>

        <para>The <literal moreinfo="none">@MaxLength</literal> annotation
        indicates the maximum number of characters that the user may enter
        into a <literal moreinfo="none">String</literal> property, or a
        <literal moreinfo="none">String</literal> parameter in an action. (It
        is ignored if applied to a property or parameter of any other type.)
        For example:</para>

        <programlisting format="linespecific">public class Customer {

    <emphasis role="strong">@MaxLength(30)</emphasis>
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
    ...
}</programlisting>

        <para>If the model is being persisted on a relational database then
        <literal moreinfo="none">@MaxLength</literal> should be specified for
        all <literal moreinfo="none">String</literal> properties and action
        parameters.</para>
      </sect1>

      <sect1>
        <title>@MemberOrder</title>

        <para><code>@MemberOrder</code> is the recommended mechanism for
        specifying the order in which fields and/or actions are presented to
        the user. (<code>@ActionOrder</code> and <code>@FieldOrder</code>
        provide alternative mechanisms).</para>

        <para><code>@MemberOrder</code> is specified at the individual member
        level, on a 'relative' basis. The syntax is:</para>

        <programlisting>@MemberOrder(sequence = "&lt;relative order&gt;")</programlisting>

        <para>where <code>&lt;relative order&gt;</code> may be any string. The
        actual sequence is determined by comparing all the values of the
        sequence specifier string, using the standard <code>String</code>
        comparator.</para>

        <para>The simplest convention is to use numbers - 1, 2, 3 - though it
        is a better idea to leave gaps in the numbers - 10, 20, 30 perhaps -
        such that a new member may be added without having to edit existing
        numbers. A useful alternative is to adopt the 'dot-decimal' notation -
        1, 1.1, 1.2, 2, 3, 5.1.1, 5.2.2, 5.2, 5.3 - which allows for an
        indefinite amount of future insertion. For example:</para>

        <programlisting>Public Class Customer {
    @MemberOrder(sequence="2.1")
    Public String getAddress() {...}
    Public void setAddress(value as String) {...}

    @MemberOrder(sequence="1.1")
    Public String getFirstName() {...}
    Public void setFirstName(value as String) {...}

    @MemberOrder(sequence="1.2")
    Public String getLastName() {...}
    Public void setLastName(value as String) {...}

    @MemberOrder(sequence="3")
    Public Date getDateOfBirth() {...}
    Public void setDateOfBirth(value as Date) {...}
    ...
}   </programlisting>

        <para>If a member does not have a specified order then it will be
        placed after those that are specified. Two members may have the same
        sequence specifier, but in such a case the relative ordering of those
        members will be indeterminate.</para>

        <para>This approach is especially useful when dealing with inheritance
        hierarchies, as it allows sub-classes to specify where their
        additional members should be placed in relation to those inherited
        from the super-class.</para>

        <para>Note that certain styles of user interface will lay out an
        object's properties and its collections separately, in which case the
        relative member order of properties and collections will be evaluated
        separately. However, since other styles of user interface may
        interleave properties and collections, it is safer to assume the
        latter.</para>
      </sect1>

      <sect1>
        <title>@MultiLine</title>

        <para>The <literal moreinfo="none">@MultiLine</literal> annotation
        provides information about the carriage returns in a <literal
        moreinfo="none">String</literal> property or action parameter. The
        annotation indicates that:</para>

        <para>- the <code>String</code> property or parameter may contain
        carriage returns, and</para>

        <para>- (optionally) the typical number of such carriage returns,
        and</para>

        <para>- (optionally) that the text should be wrapped (the default is
        that text is not wrapped).</para>

        <warning>
          <para>Currently the <literal
          moreinfo="none">preventWrapping</literal> functionality is not fully
          implemented.</para>
        </warning>

        <para>This may be used by the viewing mechanism to render the property
        as a multi-line textbox (or text-editor when changes are permitted),
        with appropriate wrapping and/or scrollbars. The syntax is:</para>

        <para><literal
        moreinfo="none">@MultiLine([numberOfLines=&lt;typicalNumberOfCRs&gt;]
        [,preventWrapping=&lt;false|true&gt;])</literal></para>

        <para>For example:</para>

        <programlisting format="linespecific">public class BugReport {
    <emphasis role="strong">@MultiLine(numberOfLines=10)</emphasis>
    public String getStepsToReproduce() { ... }
    public void setStepsToReproduce(String stepsToReproduce) { ... }
    ...
}</programlisting>

        <para>Here the <literal moreinfo="none">stepsToReproduce</literal> may
        be displayed in a text area of 10 rows, with no wrapping. A horizontal
        scrollbar may appear if the number of characters on any given row
        exceeds the width. Another example:</para>

        <programlisting format="linespecific">public class Email {
    <emphasis role="strong">@MultiLine(numberOfLines=20, preventWrapping=false)</emphasis>
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

        <para>Here the body should be displayed in a text area of 20 rows,
        with wrapping. If this attribute is combined with the <literal
        moreinfo="none">&lt;TypicalLength&gt;</literal>, then the expected
        width of the text area in the user interface will be determined by the
        value of the typical length divided by the number of specified lines.
        For example:</para>

        <programlisting format="linespecific">public class Email {
    <emphasis role="strong">@MultiLine(numberOfLines=20, preventWrapping=false)</emphasis>
    @TypicalLength(800)
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

        <para>Here the body will (likely be) displayed in a text area of 20
        rows, with 40 columns.</para>
      </sect1>

      <sect1>
        <title>@MustSatisfy</title>

        <para>The <literal moreinfo="none">@MustSatisfy</literal> annotation
        allows validation to be applied to properties using an (implementation
        of a)
        <classname>org.nakedobjects.applib.spec.Specification</classname>
        object.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@MustSatisfy(StartWithCapitalLetterSpecification.class)</emphasis>
    public String getFirstName() { ... }

    ...
}</programlisting>

        <para>The <classname>Specification</classname> is consulted during
        validation, being passed the proposed value.</para>
      </sect1>

      <sect1>
        <title>@Named</title>

        <para>The <literal moreinfo="none">@Named</literal> annotation is used
        when you want to specify the way something is named on the user
        interface i.e. when you do not want to use the name generated
        automatically by the system. It can be applied to objects, members
        (properties, collections, and actions) and to parameters within an
        action method.</para>

        <para><warning>
            <para>Generally speaking it is better to rename the property,
            collection or action. The only common case where
            <literal>@Named</literal> is common is to rename parameters for
            built-in value types. Even here though a custom value type can be
            defined using <classname>@Value</classname> so that the value type
            is used as the parameter name. @Named may also be used if the name
            needs punctuation or other symbols in the name presented to the
            user.</para>
          </warning></para>

        <bridgehead>Specifying the name of an object</bridgehead>

        <para>By default the name of an object is derived, reflectively from
        the class name. To specify a different name for an object, use the
        <literal moreinfo="none">@Named</literal> annotation in front of the
        class declaration. For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Named("Customer")</emphasis>
public class CustomerImpl implements Customer{
   ...
}</programlisting>

        <para>See also: <literal moreinfo="none">@Plural</literal>.</para>

        <bridgehead>Specifying the name of a member</bridgehead>

        <para>By default, the name of a member (a property, collection or
        action) presented to the user is derived, reflectively, from the name
        of the member defined in the program code. To specify a different name
        use the <literal moreinfo="none">@Named </literal>annotation
        immediately before the member declaration. For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Named("Given Name")</emphasis>
    public String getFirstName() { ... }

    <emphasis role="strong">@Named("Family Name")</emphasis>
    public String getSurname() { ... }

    public CreditRating getCreditRating() { ... }
}</programlisting>

        <para>Note that the framework provides a separate and more powerful
        mechanism for internationalisation.</para>

        <bridgehead>Specifying the name for an action parameter</bridgehead>

        <para>The most common usage of <literal moreinfo="none">@Named
        </literal>will be to specify names for the parameters of an action:
        because, by default, the user interface will use the type of the
        parameter as the name. (This is because the parameter name declared in
        the code for the action method cannot be picked up reflectively.) To
        specify the name of a parameter, the <literal
        moreinfo="none">@Named</literal> annotation is applied 'in-line' (i.e.
        preceding the individual parameter declaration). For example:</para>

        <programlisting format="linespecific">public class Customer {

    public Order placeOrder(
                      Product product,
                      <emphasis role="strong">@Named("Quantity")</emphasis>
                      int quantity) {

        Order order = new Order();
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>
      </sect1>

      <sect1 id="not-persistable">
        <title>@NotPersistable</title>

        <para>This annotation indicates that transient instances of this class
        may be created but may not be persisted. The framework will not
        provide the user with an option to 'save' the object, and attempting
        to persist such an object programmatically would be an error. For
        example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@NotPersistable</emphasis>
public class InputForm {
    // members and actions here
}</programlisting>

        <para>This annotation can also take a single parameter indicating
        whether it is only the user that cannot persist the object, for
        example the following code would prevent the user from saving the
        object (via the viewer) but still allow the program to persist the
        object. By default the annotated object is effectively transient, e.g.
        it is implicitly
        <classname>By</classname>.<varname>USER_OR_PROGRAM</varname>.</para>

        <programlisting format="linespecific"><emphasis role="strong">@NotPersistable</emphasis>(By.USER)
public class InputForm {
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@NotPersisted</title>

        <para>This indicates that the property is not to be persisted. Note
        that in many cases the same thing could be achieved by providing the
        property with a 'getter' but no 'setter'. For example:</para>

        <remark>Check that this is acceptable for Hibernate</remark>

        <programlisting format="linespecific">public class Order {

    private Order previousOrder;

    <emphasis role="strong">@NotPersisted</emphasis>
    public Order getPreviousOrder() {...}

    public void setPreviousOrder(Order previousOrder) {...}

    // rest of code
}</programlisting>
      </sect1>

      <sect1>
        <title>@Optional</title>

        <para>By default, the system assumes that all properties of an object
        are required, and therefore will not let the user save a new object
        unless a value has been specified for each property. Similarly, by
        default, the system assumes that all parameters in an action are
        required and will not let the user execute that action unless values
        have been specified for each parameter. To indicate that either a
        property, or an action parameter, is optional, use the <literal
        moreinfo="none">@Optional</literal> annotation.</para>

        <bridgehead>Making a property optional</bridgehead>

        <para>To indicate that a property is optional (i.e. that the user may
        save the object without necessarily specifying a value for this
        property), use the @Optional annotation immediately before the
        declaration of that property. For example:</para>

        <programlisting format="linespecific">public class Order {
    public Product getProduct() { ... }
    
    public java.util.Date getShipDate() { ... }
    public void setShipDate(Date java.util.shipDate) { ... }

    <emphasis role="strong">@Optional</emphasis>
    public String getComments() { ... }
    public void setComments(String comments) { ... }
}</programlisting>

        <para>Here the <literal moreinfo="none">product</literal> and <literal
        moreinfo="none">shipDate</literal> properties are both required, but
        the <literal moreinfo="none">comments</literal> property is
        optional.</para>

        <bridgehead>Making an action parameter optional</bridgehead>

        <para>To indicate that an action may be invoked without having to
        specify a value for a particular parameter, the
        <literal>@Optional</literal> annotation should be used in-line i.e.
        immediately before the declaration of that parameter. For
        example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
              Product product,
              @Named("Quantity") int quantity, 
              @Optional @Named("Special Instructions") String instr) {
        ....
    }
    ...
}</programlisting>

        <para>Note that the <literal
        moreinfo="none">@Optional</literal>annotation has no meaning for a
        primitive property (or parameter) such as <literal
        moreinfo="none">int</literal> - because primitives will always return
        a default value (e.g. zero). If optionality is required, then use the
        corresponding wrapper class (e.g. java.lang.Integer).</para>
      </sect1>

      <sect1>
        <title>@Plural</title>

        <para>Where Naked Objects displays a collection of several objects it
        may use the plural form of the object type in the title. By default
        the plural name will be created by adding an 's' to the end of the
        singular name (whether that is the class name or another name
        specified using <literal moreinfo="none">@Named</literal>). Where the
        single name ends in 'y' then the default plural name will end in 'ies'
        - for example a collection of <literal
        moreinfo="none">Country</literal> objects will be titled 'Countries'.
        Where these conventions do not work, the programmer may specify the
        plural form of the name using @Plural. For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Plural("Children")</emphasis>
public class Child {
    // members and actions here
}</programlisting>
      </sect1>

      <sect1>
        <title>@RegEx</title>

        <para>The <literal moreinfo="none">@RegEx</literal> annotation may be
        applied to any property, or to any parameter within an action method,
        that is a value type (i.e. that allows the user to type in text as
        input). It serves both to validate and potentially to normalise the
        format of the input. <literal moreinfo="none">@Regex</literal> is
        therefore similar in use to <literal moreinfo="none">@Mask</literal>
        but provides more flexibility. The syntax is:</para>

        <para><literal moreinfo="none">@RegEx(validation = &lt;regEx
        string&gt;, format = &lt;regEx string&gt;, caseSensitive =
        &lt;true|false&gt;)</literal></para>

        <para>The first parameter is required; the format defaults to 'no
        formatting'; caseSensitive defaults to false. When applying Regex to a
        value property, the annotation should be applied to the 'getter'. For
        example:</para>

        <programlisting format="linespecific">    private String email;

<emphasis role="strong">    @RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")</emphasis>
    public String getEmail() {}

    public void setEmail(String email) {}</programlisting>

        <para>When applying a RegEx expression to a value parameter within an
        action method, the annotation should precede that parameter:</para>

        <programlisting format="linespecific">    public void newContact(
        @Named("Contact Name")
        String contactName,
        @Named("Email")
        <emphasis role="strong">@RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")</emphasis>
        String email) {}</programlisting>
      </sect1>

      <sect1>
        <title>@TypeOf</title>

        <para>The <literal moreinfo="none">@TypeOf</literal> annotation is
        used to specify the type of elements in a collection, when it is not
        possible to use generics - for example when invoking an external
        method that does not use generics.</para>

        <programlisting format="linespecific"><emphasis role="strong">@TypeOf(Customer.class)</emphasis>
public List allNewCustomers() {
    return CustomerDatabase.allNewCustomers();
}</programlisting>
      </sect1>

      <sect1>
        <title>@TypicalLength</title>

        <para>The <literal moreinfo="none">@TypicalLength</literal> annotation
        indicates the typical length of a <literal
        moreinfo="none">String</literal> property or <literal
        moreinfo="none">String</literal> parameter in an action. This may be
        used by the viewing mechanism to determine the space that should be
        given to that property or parameter in the appropriate view. For
        example:</para>

        <programlisting format="linespecific">public class Customer {
    @MaxLength(30)
    <emphasis role="strong">@TypicalLength(20)</emphasis>
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
}</programlisting>

        <para>If the typical length is the same as the <literal
        moreinfo="none">&lt;MaxLength&gt;</literal> then there is no need to
        specify <literal moreinfo="none">&lt;TypicalLength&gt;</literal> as
        well. If the value specified is zero or negative then it will be
        ignored.</para>
      </sect1>

      <sect1>
        <title>@Value</title>

        <para>The <literal moreinfo="none">@Value</literal> annotation
        indicates that a class should be treated as a value type rather than
        as a reference (or entity) type. It does this providing an
        implementation of a
        <classname>org.nakedobjects.applib.adapters.ValueSemanticsProvider</classname>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@Value(semanticsProviderClass=ComplexNumberValueSemanticsProvider.class)
public class ComplexNumber {
    ...
}</programlisting>

        <para>The <classname>ValueSemanticsProvider</classname> allows the
        framework to interact with the value, parsing strings and displaying
        as text, and encoding/decoding (for serialization).</para>
      </sect1>
    </chapter>

    <chapter>
      <title>DomainObjectContainer</title>

      <para></para>

      <para><remark>TODO: we should have a chapter on the methods of the
      DomainObjectContainer.</remark></para>

      <sect1>
        <title></title>

        <para></para>
      </sect1>
    </chapter>
  </part>

  <part id="reference2">
    <title>Reference - Application Library</title>

    <chapter>
      <title>Services</title>

      <para>Services, which are automatically injected into any domain object
      that needs them, are just ordinary domain objects but with an
      <methodname>getId()</methodname> identity method. The method recognised
      is:</para>

      <programlisting format="linespecific">public String getId()</programlisting>

      <para>This identity method is currently used only by perspectives, when
      registering services. (Strictly speaking the
      <methodname>getId()</methodname> method is optional; if not present then
      the fully qualified class name is used as the Id).</para>

      <para>All the other methods are processed as for domain objects, as
      described in a previous section.</para>

      <para>To simplify the process of writing service objects the following
      abstract classes are available from within the application
      library:</para>

      <itemizedlist>
        <listitem>
          <para><classname>AbstractFactoryAndRepository</classname></para>
        </listitem>

        <listitem>
          <para><classname>AbstractService</classname></para>
        </listitem>
      </itemizedlist>

      <para>In addition there are classes within the framework that assist
      building services that need to integrate with the framework.</para>

      <itemizedlist>
        <listitem>
          <para><classname>RepositoryHelper</classname></para>
        </listitem>

        <listitem>
          <para><classname>ServiceException</classname></para>
        </listitem>
      </itemizedlist>

      <sect1>
        <title>Registering services</title>

        <para>Services are registered with the Framework at startup via the
        properties file, using the services properties. The
        <methodname>services</methodname> property itself dictates which
        service classes are to be instantiated at startup, for example:</para>

        <programlisting format="linespecific">nakedobjects.services = bom.BookingFactory, bom.CustomerFactoryAndRepository, \
  bom.LocationFactoryAndRepository
</programlisting>

        <para>The <methodname>prefix</methodname> property allows you to
        specify the common package once and, hence omit them from the classes
        in the list. The following set of properties is therefore equivalent
        to the previous example.</para>

        <programlisting format="linespecific">nakedobjects.services.prefix = bom
nakedobjects.services = BookingFactory, CustomerFactoryAndRepository, \
  LocationFactoryAndRepository
</programlisting>

        <sect2>
          <title>System repositories</title>

          <para>As well as services defined programmatically, it is possible
          to use a repository provided by the framework that will, for a
          configured object type, provide methods to:</para>

          <itemizedlist>
            <listitem>
              <para>Create a new transient instance</para>
            </listitem>

            <listitem>
              <para>Create a new persisted instance</para>
            </listitem>

            <listitem>
              <para>Find all persisted instances</para>
            </listitem>

            <listitem>
              <para>Find instances with a specified title</para>
            </listitem>
          </itemizedlist>

          <para>To register such a service prefix the class name with
          'repository#', for example:</para>

          <programlisting format="linespecific">nakedobjects.services = repository#bom.Booking</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>Factories/repositories</title>

        <para><remark>TODO</remark></para>
      </sect1>

      <sect1>
        <title>Other services</title>

        <para><remark>TODO</remark></para>
      </sect1>
    </chapter>

    <chapter>
      <title>Fixtures</title>

      <para>Fixtures are simple classes that are used to set up a naked
      objects system. The code for a fixture should be placed in the
      <methodname>install</methodname> method, which is run when the system
      installs the fixtures. Fixtures are only installed if the
      <classname>NakedObjectPersistor</classname> flags that it is
      uninitialised via its <methodname>isInitialized</methodname> method. For
      the in memory object store this will be every time it is started, and
      for other object stores will only be when they detect they have no
      persistent data.</para>

      <sect1>
        <title>Registering fixtures</title>

        <para>Fixtures are registered with the Framework at startup via the
        properties file, using the fixtures properties. The
        <methodname>fixtures</methodname> property itself dictates which
        fixture classes are to be instantiated at startup, for example:</para>

        <programlisting format="linespecific">nakedobjects.fixtures = fixture.BookingsFixture, fixture.PerspectivesFixture</programlisting>

        <para>The <methodname>prefix</methodname> property allows you specify
        the common package name once and, hence omit them from the classes in
        the list. The following set of properties is therefore equivalent to
        the previous example.</para>

        <programlisting format="linespecific">nakedobjects.fixtures.prefix = fixture
nakedobjects.fixtures = BookingsFixture, PerspectivesFixture</programlisting>
      </sect1>
    </chapter>
  </part>

  <part id="reference3">
    <title>Reference - Runtime</title>

    <chapter>
      <title id="command-line-parameters">Command line parameters</title>

      <para>A bootstrapper takes care of loading up the Naked Objects
      framework and application, initialising it, and running it. When it
      starts up it reads in a list of components and attempts to load in each
      one. Any component that can be loaded is then available to be used and
      can then be specified on the command line if required. Requesting a
      component that cannot be loaded will result in an error. To resolve such
      an error simply ensure that the component's Jar file is available on the
      class path. All the components supplied with the framework are listed in
      the file <filename class="directory"
      moreinfo="none">installer-registry.properties</filename> which is part
      of the <filename class="directory"
      moreinfo="none">runtime-4.0.jar</filename> file.</para>

      <para>During start-up Naked Objects loads in a number of configuration
      files. The main file, <filename class="directory"
      moreinfo="none">nakedobjects.properties</filename>, is always loaded and
      must be present for the framework to start up. For each of the various
      types of persistor and viewer, there is a separate configuration file.
      For example, for the following command line parameters</para>

      <screen format="linespecific">-v dnd -r xml</screen>

      <para>specifies that the viewer is to be the drag and drop (<literal
      moreinfo="none">dnd</literal>) interface, and the persistor is to be the
      'xml object store'. As well as loading those components, the framework
      will look for configuration files named
      <filename>viewer.properties</filename>, <filename class="directory"
      moreinfo="none">viewer_dnd.properties</filename>,
      <filename>persistor.xml</filename> and <filename class="directory"
      moreinfo="none">persistor_xml.properties</filename> and will load them
      if found.</para>

      <sect1>
        <title>Options</title>

        <para>The bootstrapper is the class
        <classname>org.nakedobjects.runtime.NakedObjects</classname> and takes
        the following options on the command line. (Note that in each case
        there is an abbreviated, and a full, version of the option).</para>

        <para>There is also an alternative bootstrapper,
        org.nakedobjects.webserver.WebServer.</para>

        <sect2>
          <title>Configuration</title>

          <screen format="linespecific">-c &lt;config file&gt;
--config &lt;config file&gt;</screen>

          <para>Loads in the specified configuration file, in addition to
          <filename class="directory"
          moreinfo="none">nakedobjects.properties</filename> and the
          properties files relating to the installed component.</para>
        </sect2>

        <sect2>
          <title>Disable splash</title>

          <screen format="linespecific">-s
--nosplash</screen>

          <para>Prevents the splash screen from being displayed during start
          up.</para>
        </sect2>

        <sect2>
          <title>Help</title>

          <screen format="linespecific">-h
--help</screen>

          <para>Prints out the options that are available. This is dynamic so
          that only the components that can be used are listed.</para>
        </sect2>

        <sect2>
          <title>Logging</title>

          <para>The amount of logging detail can be controlled from the
          command line. If no flag is specified only warnings and errors are
          output. All logging level relate to the Log4J levels, which is the
          logging mechanism used by Naked Objects.</para>

          <screen format="linespecific">-quiet</screen>

          <para>Quiet reduces logging to show errors only.</para>

          <screen format="linespecific">-verbose</screen>

          <para>Increases logging to show information about the system as it
          runs.</para>

          <screen format="linespecific">-debug</screen>

          <para>Increases logging to show all logged entries. At this level so
          much is logged that it will likely slow down the system if used when
          outputting log details to the console or other slow devices.</para>
        </sect2>

        <sect2>
          <title>Deployment Type (or Mode)</title>

          <screen format="linespecific">-t &lt;mode&gt;
--type &lt;mode&gt;</screen>

          <para>The framework is started up in one of several different
          deployment modes, as listed below:</para>

          <para><emphasis>exploration</emphasis> - Exploration mode is for
          developers to explore and test their code. The framework always uses
          an in-memory persistor and runs the fixtures at startup to ensure a
          known state every time the system is started. The user is not
          prompted to log in, but is automatically logged in as user
          'exploration'. The logged in user can be changed on the fly using an
          option with the user interface; this simply changes the user and
          does not require an explicit login action. Also, exploration methods
          defined in the DOM are also available to the user to do things that
          a user would not normally be allowed to do. These are used expressly
          for testing the system. Please note it is an error to specify a
          persistor type in exploration mode.</para>

          <para><emphasis>prototype</emphasis> - Prototype mode is for
          demonstrating the system in realistic fashion. The user is always
          prompted to log in at start up, and can log out and log in again
          without losing the state of the objects. This allows a user to
          demonstrate exactly how a system would work.</para>

          <para><emphasis>single-user</emphasis> - Single user mode runs the
          system for a single user with object persistence.</para>

          <para><emphasis>client</emphasis> - Client mode provides multiple
          users access to a server. With this mode selected the
          <emphasis>connection</emphasis> option must also be
          specified.</para>

          <para><emphasis>server-exploration</emphasis> - Server mode, but all
          clients will automatically be logged in as the 'exploration' user
          (or as <classname>LoginFixture</classname> is present).</para>

          <para><emphasis>server-prototype</emphasis> - Server mode, but if a
          <classname>LoginFixture</classname> is present then all clients will
          automatically be logged in as this user.</para>

          <para><emphasis>server</emphasis> - Server mode runs Naked Objects
          as a server for multiple clients. With this mode selected the
          <emphasis>connection</emphasis> option must also be
          specified.</para>

          <para>If no mode is specified, the framework will start up in
          <emphasis>prototype</emphasis> mode.</para>
        </sect2>

        <sect2>
          <title>Overridden properties</title>

          <screen format="linespecific">-D property=value</screen>

          <para>Using this flag we can pass in properties from the command
          line that would otherwise need to specified in a configuration file.
          This is normally used to override a property, or to temporarily
          specify one.</para>
        </sect2>

        <sect2>
          <title>Password</title>

          <screen format="linespecific">-p &lt;password&gt;
--password &lt;password&gt;</screen>

          <para>Ignored if type is prototype or not used with the user option
          below.</para>

          <para>Uses the specified password when logging the user in with the
          username specified with <methodname>--user</methodname>.</para>
        </sect2>

        <sect2>
          <title>Persistor</title>

          <screen format="linespecific">-r &lt;persistor&gt;
--persistor &lt;persistor&gt;</screen>

          <para>Ignored if type is client.</para>

          <para>The persistor option allows you to choose how the objects
          created by the system will be persisted so they are still available
          the next time you run the system. The following options are
          available with the current distribution, and if none is specified
          then the in-memory persistor will be used for exploration mode and
          xml persistor will be used for other non-client modes by
          default.</para>

          <para><emphasis>in-memory</emphasis> - A simple non-persisting
          mechanism that will only hold the persisted object while the virtual
          machine is running. This is used for testing and
          demonstrating.</para>

          <para><emphasis>xml</emphasis> - A simple file based mechanism that
          encodes each object's data in an XML file. Alongside the data files
          for the objects are instance lists listing all the files for each
          type of object.<emphasis></emphasis></para>

          <para><emphasis>&lt;class name&gt;</emphasis> - By specifying a
          class name the boot loader will load up that class as the
          persistor.</para>
        </sect2>

        <sect2>
          <title>Remote connector</title>

          <screen format="linespecific">-x &lt;connector&gt;
--connector &lt;connector&gt;</screen>

          <para>Ignored if mode is not a client. If the type is a client then
          a connection mechanism can be specified. Connector mechanisms
          available are:-</para>

          <para><emphasis>encoding-sockets</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          TCP/IP sockets.</para>

          <para><emphasis>encoding-http</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          HTTP.</para>

          <para><emphasis>serializing-sockets</emphasis> - Uses Java
          serialization (of value types) to serialize/deserialize objects,
          over TCP/IP sockets.</para>

          <para><emphasis>xstream-sockets</emphasis> - Uses the Xstream
          library to serialize/deserialize objects to/from XML for simple
          stream communications, over TCP/IP sockets.</para>
        </sect2>

        <sect2>
          <title>User</title>

          <screen format="linespecific">-u &lt;user name&gt;
--user &lt;user name&gt;</screen>

          <para>Ignored if type is prototype.</para>

          <para>Uses the specified name when logging the user in. If the
          password is also specified (see above) then an attempt to log in
          using the supplied user name and password is made; authentication
          failure at this point will exit the program.</para>
        </sect2>

        <sect2>
          <title>Viewer</title>

          <screen format="linespecific">-v &lt;viewer&gt;
--viewer &lt;viewer&gt;</screen>

          <para>The viewer option allows you to choose the user interface that
          is used to access your Naked Objects application. The following
          options are available with the current distribution, and if none is
          specified then the drag and drop view will be used by
          default.</para>

          <para><emphasis>dnd</emphasis> - Drag and Drop viewer</para>

          <para><emphasis>html</emphasis> - Web browser viewer - accessed via
          standard web browser such as FireFox, Internet Explorer or
          Opera</para>

          <para><emphasis>encoding-sockets</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          TCP/IP sockets.</para>

          <para><emphasis>encoding-http</emphasis> - Uses the encoding
          mechanism (of value types) to serialize/deserialize objects, over
          HTTP.</para>

          <para><emphasis>serializing-sockets</emphasis> - Uses Java
          serialization (of value types) to serialize/deserialize objects,
          over TCP/IP sockets.</para>

          <para><emphasis>xstream-sockets</emphasis> - Uses the Xstream
          library to serialize/deserialize objects to/from XML for simple
          stream communications, over TCP/IP sockets.</para>

          <para><emphasis>&lt;class name&gt;</emphasis> - By specifying a
          class name the boot loader will load up that class as the
          viewer</para>
        </sect2>
      </sect1>
    </chapter>

    <chapter id="images">
      <title>Images</title>

      <para>All images must be held in a directory called <filename
      class="directory" moreinfo="none">images</filename> in the working
      directory, or on the classpath.</para>

      <para>Images for objects are picked up by class name in the form of
      <filename class="directory"
      moreinfo="none">&lt;ClassName&gt;.&lt;extension</filename>&gt; and will
      be case sensitive on Unix/Linux, but case insensitive on Windows.</para>

      <para>The names of the images can be overriden by the reflector, which
      can pass back a name of an image that is found from the domain object.
      This provides a mechanism for objects to be shown with images that they
      themselves specify.</para>

      <para><emphasis>Extensions</emphasis> that are currently supported are
      <filename class="directory" moreinfo="none">.gif</filename>, <filename
      class="directory" moreinfo="none">.png</filename>, <filename
      class="directory" moreinfo="none">.jpg</filename> and <filename
      class="directory" moreinfo="none">.jpeg</filename>.</para>

      <para><emphasis>ClassName</emphasis> is either the short form or the
      fully qualified name of the class, and case can be important depending
      on the platform.</para>

      <para>When loading images based on class, if no image is found for the
      current class using the above variations then the process is repeated
      using the name (both short and fully qualified) of the class's immediate
      superclass. This process repeats until there are no more
      superclasses.</para>

      <sect1>
        <title>Images used by the framework</title>

        <para>There are a number of generic images that are used by the
        framework, and that can be changed to create a different look. These
        are:-</para>

        <itemizedlist>
          <listitem>
            <para><literal>empty-field.png</literal></para>
          </listitem>

          <listitem>
            <para><literal>logo.jpg</literal></para>
          </listitem>

          <listitem>
            <para><literal>small-logo.png</literal></para>
          </listitem>

          <listitem>
            <para><literal>transient.png</literal></para>
          </listitem>

          <listitem>
            <para><literal>unknown.png</literal></para>
          </listitem>
        </itemizedlist>
      </sect1>
    </chapter>

    <chapter>
      <title>File name conventions used within Naked Objects
      distributions</title>

      <sect1>
        <title>File names</title>

        <para>The names given to the download files indicate what the product
        is, which platform it runs on and its version. The version indicates
        the stage of development and how stable the system should be. The file
        name format is as follows:</para>

        <screen format="linespecific">nakedobjects-[version]-[type].[file-type]</screen>

        <para>For example:-</para>

        <screen format="linespecific">nakedobjects-4.0.1-for-maven.zip
nakedobjects-4.0-for-ant.tar.gz
nakedobjects-4.0-libs-only-with-dependencies.jar 
nakedobjects-4.1-source.zip</screen>

        <para>The parts of the name are:</para>

        <variablelist>
          <varlistentry>
            <term>version</term>

            <listitem>
              <para>See next section</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>type</term>

            <listitem>
              <para>We provide the framework in a number of ways depending on
              how you want to work with it. The <emphasis>source</emphasis> is
              the most basic and requires the most work before the framwork
              can be used. This distribution allows you to regenerate the
              distributions, but does require Maven. The source distribution
              is simply an alternative to checking the code out from the
              Subversion repository. The <emphasis>for-maven</emphasis> and
              <emphasis>for-ant</emphasis> distributions provide all the
              required files to develop and run applications using the Maven
              and Ant build tools. The maven distribution is relatively small
              download as framework libraries are downloaded by Maven only
              when you actually build an application. An alternative to
              complete package is the
              <emphasis>libs-only-with-dependencies</emphasis>, which simply
              provides all the classes for the framework and dependent
              libraries in a single jar file that can be added straight to the
              class path, so there is no need to unpack it.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>file-type</term>

            <listitem>
              <para>The file type is <filename>jar</filename>, <filename
              moreinfo="none">zip</filename> or <filename
              moreinfo="none">tar.gz</filename> (GNU compressed tar).</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect1>

      <sect1>
        <title>Versions</title>

        <variablelist>
          <varlistentry>
            <term>n.n.n</term>

            <listitem>
              <para>Stable release, with version number split into major,
              minor and fix components. Major versions develop upon, but do
              not limit themselves to, the previous major version. Minor
              versions extend the previous version while maintaining
              compatibility with them. Fix versions fix problems in the
              existing version, but do not add any new functionality.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>n.n-alpha-n or n.n-beta-n</term>

            <listitem>
              <para>Development release are releases are relatively stable
              versions of the framework that introduce new functionality that
              is part of the development plan for the versioned release. The
              milestones precede the versioned releases, that is 4.1-alpha-1
              will be released as part of the development of 4.1.
              Functionality within the alpha or beta release for a major
              version is not fixed and may change as further development takes
              place.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>n.n-wip-n</term>

            <listitem>
              <para>Work in progress releases are made during the development
              of the current version to exhibit a particular state of develop
              - such as new features, major changes or important bug fixes.
              These should generally be stable as they are not normally
              released when the code has known major problems.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>n.n.n-SNAPSHOT</term>

            <listitem>
              <para>Snapshot releases are available from every completed
              build, and hence may not even be runnable, depending the state
              of development. These are generally a way to keep up with latest
              development without using subversion.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect1>
    </chapter>

    <chapter>
      <title>Configuration</title>

      <sect1>
        <title>Configuration Settings</title>

        <para>The configuration file (<filename class="directory"
        moreinfo="none">nakedobjects.properties</filename>) needs to specify
        what resources are used by the application and what fixtures to load.
        These details are common to all the modes that the NOF can be run in.
        Additional properties can be also specified for use in specific modes,
        such as database connection details when using the SQL object
        store.</para>

        <para>The configuration file <filename class="directory"
        moreinfo="none">nakedobjects.properties</filename> is always picked
        up. In addition other properties files will be picked up, if present,
        based on the type, viewer, persistor and connection command line
        switches with the filename matching the option. E.g.</para>

        <para>-r (or --persistor) hibernate will cause
        <filename>persistor.properties</filename> and <filename
        class="directory"
        moreinfo="none">persistor_hibernate.properties</filename> to be
        used</para>

        <para>-t (or --type) client will cause <filename class="directory"
        moreinfo="none">client.properties</filename> to be used</para>

        <para>-v (or --viewer) dnd will cause
        <filename>viewer.properties</filename> and <filename class="directory"
        moreinfo="none">viewer_dnd.properties</filename> to be used</para>

        <para>-x (or -- connector) xstream-sockets will cause
        <filename>transport.properties</filename>,
        <filename>transport_sockets.properties</filename>,
        <filename>protocol.properties</filename> and
        <filename>protocol_xstream.properties</filename> to be loaded; because
        of the way that connector is implemented it will also load
        <classname>persistor.properties</classname> and <filename
        class="directory"
        moreinfo="none">persistor_xstream-sockets.properties</filename>
        too.</para>

        <para>In addition a particular file can be selected with the -c
        switch. For example</para>

        <para>-c <filename class="directory"
        moreinfo="none">mysettings.properties</filename></para>

        <sect2>
          <title>Properties file contents</title>

          <para>Each properties file can contain lists of services and
          fixtures as well as any specific settings (e.g. Hibernate setting).
          Services are defined using the
          <methodname>nakedobjects.services</methodname> property, fixtures by
          the <methodname>nakedobjects.fixtures</methodname> property.</para>

          <para>As a shortcut you can specify the prefix for all classes
          listed in the <methodname>services</methodname> property using
          <methodname>services.prefix</methodname> and the
          <methodname>fixtures</methodname> property using
          <methodname>fixtures.prefix</methodname>.</para>

          <programlisting format="linespecific"># uncomment to hide splash
#nakedobjects.nosplash
nakedobjects.locale=en_GB
nakedobjects.services.prefix = org.nakedobjects.example.expenses
nakedobjects.services = resources.ExpenseTypeFactory \
                       , resources.naive.NaiveClaimRepository\
                       , resources.naive.NaiveEmployeeRepository\
                       , resources.naive.NaiveExpenseTypeRepository\
                       , resources.naive.NaiveItemRepository

nakedobjects.fixtures.prefix=org.nakedobjects.example.expenses.fixture
nakedobjects.fixtures=ExpenseTypes, Employees, ExampleClaim, Context</programlisting>

          <para>Other settings that can be set include</para>

          <itemizedlist>
            <listitem>
              <para>nakedobjects.nosplash</para>
            </listitem>

            <listitem>
              <para>nakedobjects.locale (e.g. en_GB)</para>
            </listitem>
          </itemizedlist>

          <para>See the relevant section for details of settings specific to
          persistence, web viewer etc.</para>

          <para>The <filename class="directory"
          moreinfo="none">logging.properties</filename> file allows control
          over the logging settings. The NOF uses log4j for logging so please
          refer to <ulink
          url="http://logging.apache.org/log4j/docs/documentation.html">Apache</ulink>
          log4j documentation.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Reflector Properties</title>

        <sect2>
          <title>Value formats</title>

          <sect3>
            <title>Byte format</title>

            <para>The format for all bytes can be set, replacing the default
            format derived from the system, using the following property to
            specify a mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.byte=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Date Format</title>

            <para>The format for all dates can be set, replacing the default
            format derived from the system, using the following property to
            specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.date=dd/MM/yy</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Date/time Format</title>

            <para>The format for all date/time values can be set, replacing
            the default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.datetime=dd/MM/yy</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Decimal format</title>

            <para>The format for <classname>Bigdecimal</classname> values can
            be set, replacing the default format derived from the system,
            using the following property to specify a mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.decimal=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Double format</title>

            <para>The format for all double values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.double=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Float format</title>

            <para>The format for all float values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.float=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Integer format</title>

            <para>The format for all integers (including
            <classname>BigInteger</classname>) can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.int=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Long format</title>

            <para>The format for all long values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.long=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Short format</title>

            <para>The format for all short values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.short=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Time Format</title>

            <para>The format for all time values can be set, replacing the
            default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.time=ddMMyyyy hhmm</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>

          <sect3>
            <title>Timestamp Format</title>

            <para>The format for time stamp values can be set, replacing the
            default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">nakedobjects.value.format.timestamp=hh:mm</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>

            <para>This setting can be overriden for a specific field using the
            <link linkend="mask-annotation"> <literal
            moreinfo="none">@Mask</literal> annotation</link>.</para>
          </sect3>
        </sect2>

        <sect2>
          <title>Reflector facet decorators</title>

          <para>The reflector facet-decorators property specifies a list of
          <classname>FacetDecoratorInstaller</classname> objects that should
          be installed and registered with the reflector. These decorators
          decorate specific facets of the metamodel, allowing it change or
          modify their behaviour. This allows us to add internationalization,
          help look up and other features. Although transaction management is
          also achieved by decorating the reflector this is done automatically
          and does not need to be specified using this property. The following
          example adds a single decorator that provide internationalization
          via resource files.</para>

          <programlisting format="linespecific">nakedobjects.reflector.facet-decorators=resource-i18n</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>Exploration Properties</title>

        <sect2>
          <title>Users</title>

          <para>The list of users that can be switched between during
          exploration can be listed, separated by commas, with the following
          property. If no users are specified the default user "exploration"
          will be used and switching between users will not be
          possible.</para>

          <programlisting format="linespecific">nakedobjects.exploration.users=sven, dick, bob</programlisting>
        </sect2>

        <sect2>
          <title>Exploration options</title>

          <para>To disable the showing of exploration menu items set the
          following property to false (by default exploration options are
          shown).</para>

          <programlisting format="linespecific">nakedobjects.exploration.show=false</programlisting>
        </sect2>
      </sect1>

      <sect1 id="i18n-files" label="">
        <title>Internationalization resource files</title>

        <sect2>
          <title>Files</title>

          <para>Translated names, descriptions and help text for a specific
          language should be held in a file named in the following
          format:</para>

          <screen format="linespecific">i18n_&lt;language code&gt;_&lt;country code&gt;.properties</screen>

          <para>The language and country codes must reflect the translated
          language are ISO standards and are detailed in the <link
          linkend="locale">Locale section</link>.</para>

          <para>Theses files must be on the root of the class path, otherwise
          they cannot be loaded.</para>
        </sect2>

        <sect2>
          <title>Properties</title>

          <para>Each property can have a line for each of the name,
          description and help text. The format for each is shown
          below.</para>

          <programlisting format="linespecific">&lt;fully qualified class name&gt;.property.&lt;property name&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.property.&lt;property name&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.property.&lt;property name&gt;.help=&lt;translated help&gt;</programlisting>

          <para>The class name must be fully qualified and the property name
          is the short name provided by the reflector. All the values are case
          sensitive. The following shows the translated name and description
          being specified for the property <emphasis>fullName</emphasis>,
          which is defined by the <methodname>getFullName</methodname>
          method.</para>

          <programlisting format="linespecific">example.dom.Contact.property.fullName.name=Nom
example.dom.Contact.property.fullName.description=Le nom complet du client</programlisting>
        </sect2>

        <sect2>
          <title>Collections</title>

          <para><remark>TODO: presumably i18n is supported for collections,
          too?</remark></para>
        </sect2>

        <sect2>
          <title>Actions</title>

          <para>Actions are specified in a similar fashion to properties but
          with the keyword <emphasis>action</emphasis> instead of
          <emphasis>property</emphasis>. Parameters within an action can also
          be translated by inserting <emphasis>parameter</emphasis> and a
          number before the keyword. Each parameter must be numbered to show
          its position, starting from one (1), eg
          <emphasis>parameter1</emphasis>, <emphasis>parameter2</emphasis>
          etc.</para>

          <programlisting format="linespecific">&lt;fully qualified class name&gt;.action.&lt;action name&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.help=&lt;translated help&gt;

&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.name=&lt;translated name&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.description=&lt;translated description&gt;
&lt;fully qualified class name&gt;.action.&lt;action name&gt;.parameter&lt;index&gt;.help=&lt;translated help&gt;</programlisting>

          <para>The class name must be fully qualified and the action name is
          the short name provided by the reflector. All the values are case
          sensitive. The following shows the translated action name and
          description, and two parameter names being specified for the action
          <emphasis>createPhone</emphasis>, which is defined by the
          <methodname>createPhone</methodname> method.</para>

          <programlisting format="linespecific">example.dom.Contact.action.createPhone.name=Nouveau téléphone
example.dom.Contact.action.createPhone.parameter1.name=Indicatif de zone
example.dom.Contact.action.createPhone.parameter2.name=Nombre
example.dom.Contact.action.createPhone.description=Créez un nouveau téléphone et ajoutez-le au contact actuel</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>Viewer Properties</title>

        <para>The look of the viewing mechanism can be changed by using
        different fonts, colours and icons. All viewer properties for the drag
        and drop user interface have a common root of
        <methodname>nakedobjects.viewer.dnd</methodname> and for the HTML
        interface <methodname>nakedobjects.viewer.html</methodname>.</para>

        <sect2>
          <title>Initial size and location</title>

          <para>The size and location of the application within the windowing
          systems can be specified using the
          <methodname>initial.size</methodname> and
          <methodname>initial.location</methodname> properties. If not
          specified the size defaults to nearly full screen and location to
          near the top-left corner.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.initial.size = 800 x 600
nakedobjects.viewer.dnd.initial.location = 100, 200</programlisting>
        </sect2>

        <sect2>
          <title>Large icon size</title>

          <para>The width of the resource icons (as shown on the desktop) can
          be specified using the <methodname>large-icon-size</methodname>
          property. If not specified it will default to 34 pixels.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.large-icon-size = 48</programlisting>
        </sect2>

        <sect2>
          <title>Resize border</title>

          <para>The amount of space allocated for the resize border on a text
          field can be set using the
          <methodname>field-resize-border</methodname> property. Unless set
          this will default to 5 pixels.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.field-resize-border = 3</programlisting>

          <para>The amount of space allocated for the resize border on a tree
          view can be set using the
          <methodname>tree-resize-border</methodname> property. Unless set
          this will default to 5 pixels.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.tree-resize-border = 3</programlisting>
        </sect2>

        <sect2>
          <title>Exploration menu options</title>

          <para>To turn off exploration menus set the
          <methodname>show-exploration</methodname> property to
          <emphasis>off</emphasis>.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.show-exploration = off</programlisting>
        </sect2>

        <sect2>
          <title>Double buffering</title>

          <para>The whole viewer is double buffered by default, but this can
          be turned off by setting the <methodname>double-buffer</methodname>
          property to <emphasis>off</emphasis>.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.double-buffer = off</programlisting>
        </sect2>

        <sect2>
          <title>Background logo</title>

          <para>A background logo can be added to the workspace using the
          <methodname>logo-background</methodname> properties. The image
          sub-property indicates that a logo should be displayed and what
          image to use. The size and location are then optional.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.logo-background.image = background.jpg
nakedobjects.viewer.dnd.logo-background.size = 400 x 300
nakedobjects.viewer.dnd.logo-background.location = 100, 200</programlisting>
        </sect2>

        <sect2>
          <title>Loading images from files</title>

          <para>Images are normally loaded directly from the Java resources
          (accessed via the class path) or as files within the <filename
          class="directory" moreinfo="none">images</filename> directory. If
          necessary the loading of files can be suspended so they are only
          loaded from resources. This is done via the
          <methodname>load-images-from-files</methodname> property.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.load-images-from-files = false</programlisting>
        </sect2>

        <sect2>
          <title>Padding</title>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.hpadding = 5
nakedobjects.viewer.dnd.vpadding = 5</programlisting>
        </sect2>

        <sect2>
          <title>Default image</title>

          <para>The default image is the one used if the image file/resource
          that should be used cannot be found. This simply ensures that an
          image is available for all icons. The default image can be changed
          using the <methodname>default-image</methodname> property.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.default-image = square.png</programlisting>
        </sect2>

        <sect2>
          <title>Image directory</title>

          <para>The directory in which the images are to be found can be
          specified via the <methodname>image-directory</methodname>
          property.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.image-directory = graphics</programlisting>
        </sect2>

        <sect2>
          <title>View specifications</title>

          <para>The views used to render objects and collection are created by
          view specifications. These specifications are installed at start up
          and can be added to. The <methodname>specification.view</methodname>
          property lists the specifications to load.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.specification.view = org.nakedobjects.viewer.skylark.basic.FormSpecification, \
        org.nakedobjects.viewer.skylark.basic.ListSpecification</programlisting>

          <para>The viewer has a set of default set of views that it loads up,
          these include specifications for forms, lists, tree browsers and
          tables. To disable this default set, normally so you can explicitly
          set up the specification list as above, use the
          <methodname>specification.defaults</methodname> property with the
          <emphasis>false</emphasis> value.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.specification.defaults =off
</programlisting>

          <para>Specific field and subview types can be also specified, so
          they no longer use the built-in default. These all have the same
          property name root of
          <methodname>nakedobjects.viewer.dnd.specification</methodname> and
          are:-</para>

          <itemizedlist>
            <listitem>
              <para><property moreinfo="none">field.image</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">field.color</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">field.password</property></para>
            </listitem>

            <listitem>
              <para><property
              moreinfo="none">field.wrappedtext</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">field.checkbox</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">field.text</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">field.empty</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">icon.subview</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">icon.object</property></para>
            </listitem>

            <listitem>
              <para><property moreinfo="none">icon.resource</property></para>
            </listitem>
          </itemizedlist>

          <para>The following example causes all logical properties to be
          shown using the standard text field rather than the default check
          box.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.specification.field.checkbox = \
        org.nakedobjects.viewer.skylark.basic.TextFieldSpecification</programlisting>
        </sect2>

        <sect2>
          <title>Fonts</title>

          <para>Fonts can be specified using the following font property
          names:-</para>

          <itemizedlist>
            <listitem>
              <para><methodname>control</methodname>, for the text in control
              widgets such as buttons</para>
            </listitem>

            <listitem>
              <para><methodname>label</methodname>, for the field
              labels</para>
            </listitem>

            <listitem>
              <para><methodname>large-icon</methodname>, for the icons on the
              desktop such as resources</para>
            </listitem>

            <listitem>
              <para><methodname>menu</methodname>, for the menu options</para>
            </listitem>

            <listitem>
              <para><methodname>normal</methodname>, for edit fields and
              object labels in fields</para>
            </listitem>

            <listitem>
              <para><methodname>small-title</methodname>, for windows
              bars</para>
            </listitem>

            <listitem>
              <para><methodname>status</methodname>, for text on the status
              bar</para>
            </listitem>

            <listitem>
              <para><methodname>title</methodname>, for titling objects</para>
            </listitem>
          </itemizedlist>

          <para>A particular font can be specified for an area by
          specifying</para>

          <programlisting format="linespecific">org.nakedobjects.viewer.dnd.font.&lt;area&gt;=&lt;font&gt;</programlisting>

          <para>Where the <methodname>&lt;area&gt;</methodname> is the name
          and the <methodname>&lt;font&gt;</methodname> is specified according
          the <methodname>Font.decode()</methodname> specification
          (<classname>see java.awt.Font</classname>). This essentially is a
          concatenation of the name, style and size as below:</para>

          <programlisting format="linespecific">&lt;logical font name&gt;-&lt;style&gt;-&lt;point size&gt;</programlisting>

          <para>In addition to the font the amount of space between lines of
          text can also be specified.</para>

          <programlisting format="linespecific">org.nakedobjects.viewer.dnd.spacing.&lt;area&gt;=&lt;pixels&gt;</programlisting>
        </sect2>

        <sect2>
          <title>Colours</title>

          <para>The colour properties are prefixed with
          <methodname>nakedobjects.viewer.dnd.color</methodname> and take a
          numerical value. The most useful form is in hexadecimal where the
          six digits are grouped into twos to represent the red, green and
          blue components. The following example specifies the colours green,
          red and black respectively.</para>

          <screen format="linespecific">nakedobjects.viewer.dnd.color.normal=0x0000FF
nakedobjects.viewer.dnd.color.label=0xFF0000
nakedobjects.viewer.dnd.color.text.edit=0xFFFFFF</screen>

          <para>The basic colour scheme is made up of a palette of eight
          colours: three primary, three secondary and black and white. These
          form the basis for many of the other colour properties. The colour
          property names are:-</para>

          <itemizedlist>
            <listitem>
              <para><methodname>black</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>white</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>primary1</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>secondary1</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>primary2</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>secondary2</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>primary3</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>secondary3</methodname></para>
            </listitem>
          </itemizedlist>

          <para>The backgrounds of the application, the windows and the menus
          can be set with the following properties:-</para>

          <itemizedlist>
            <listitem>
              <para><methodname>background.application</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>background.window</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>background.content-menu</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>background.value-menu</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>background.view-menu</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>background.workspace-menu</methodname></para>
            </listitem>
          </itemizedlist>

          <para>In addition to the setting of a colour for all window
          backgrounds you can also set the colour for a specific view
          type.</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.color.background.window.List=0x00ffff</programlisting>

          <para>The colours of the text on the menus can be specified with the
          following properties:-</para>

          <itemizedlist>
            <listitem>
              <para><methodname>menu.normal</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>menu.disabled</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>menu.reversed</methodname></para>
            </listitem>
          </itemizedlist>

          <para>The state of the views can be reflected by its colour. The
          following colour properties can be specified (only the identified
          property is based on the core colour scheme, all others are unique
          by default):-</para>

          <itemizedlist>
            <listitem>
              <para><methodname>identified</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>valid</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>invalid</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>active</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>error</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>out-of-synch</methodname></para>
            </listitem>
          </itemizedlist>

          <para>There are a number of properties relating to text for text
          fields. These are the colour of text when editing it, the cursor's
          colour, the colour of the highlight when selecting text, and the
          colour of text when it has focus for editing but has not been
          changed yet.</para>

          <itemizedlist>
            <listitem>
              <para><methodname>text.edit</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>text.cursor</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>text.highlight</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>text.saved</methodname></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Echo character</title>

          <para>The single character used to represent an entered character in
          a password field can be specified with the
          <methodname>echo</methodname> property, for example to change it
          from the default * to a hash specify the following:</para>

          <programlisting format="linespecific">nakedobjects.viewer.dnd.echo=#</programlisting>
        </sect2>

        <sect2>
          <title>HTML viewer</title>

          <para>The html viewer has only two properties</para>

          <programlisting format="linespecific">nakedobjects.viewer.html.debug=true</programlisting>

          <para>Which enables debugging on the web controller.</para>

          <programlisting format="linespecific">nakedobjects.viewer.html.encoding=UTF-8</programlisting>

          <para>Which enables the character set encoding used by the
          HTTPServletRequest. This is ISO-8859-1 by default.</para>
        </sect2>

        <sect2>
          <title>Embedded Web Server</title>

          <para>The embedded web server (implemented by Jetty) has only one
          properties</para>

          <programlisting format="linespecific">nakedobjects.embedded-web-server.port=8080</programlisting>

          <para>Which specifies the port to use when prototyping.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Other Properties</title>

        <sect2 id="locale">
          <title>Locale</title>

          <para>The locale that the system works in can be set by the
          following property:</para>

          <programlisting format="linespecific">nakedobjects.locale = en_GB</programlisting>

          <para>The locale is specified in two parts separated by an
          underscore.</para>

          <para>The first part is the language and is a valid ISO Language
          Code. These codes are the lower-case, two-letter codes as defined by
          ISO-639. You can find a full list of these codes at a number of
          sites, such as: <ulink
          url="???">http://www.loc.gov/standards/iso639-2/php/English_list.php</ulink>
          The second part is the country and is a valid ISO Country Code.
          These codes are the upper-case, two-letter codes as defined by
          ISO-3166. You can find a full list of these codes at a number of
          sites, such as: <ulink
          url="???">http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html</ulink></para>

          <para>If no underscore is used then the setting is deemed to be the
          language.</para>

          <para>If no locale is specified the system uses the locale specified
          by the operating system.</para>
        </sect2>

        <sect2>
          <title>Time zone</title>

          <para>The time zone that the system works in can be set by the
          following property:</para>

          <programlisting format="linespecific">nakedobjects.timezone = Europe/London</programlisting>

          <para>The time zone is normally a geographic area and a location
          separated by a slash (/), such as
          <emphasis>America/New_York</emphasis>,
          <emphasis>Europe/Paris</emphasis> or
          <emphasis>Australia/Perth</emphasis>. These codes can be looked up
          online on sites such as <ulink
          url="http://www.convertit.com/Go/ConvertIt/World_Time/Current_Time.ASP">ConvertIt.com</ulink>
          and <ulink url="http://twiki.org/cgi-bin/xtra/tzdatepick.html">Date
          and Time Gateway</ulink>.</para>

          <para>Alternatively the time zone can be specified in relative
          format of the form <emphasis>GMT-8:00</emphasis> where the relative
          number of hours and minutes can be specified.</para>
        </sect2>
      </sect1>
    </chapter>
  </part>
</book>